# 图解设计模式读书笔记

## Iterator（迭代器）模式

可以无视集合的实现，完成对集合的遍历。可以透明的变更集合的实现。

> 为了弱化类之间的耦合，进而使得类更容易作为组件被复用，我们需要引入抽象类和接口。
>
> 不要只使用具体类来编程，要优先使用抽象类和接口来编程。



## Adapter（适配器）模式

适配器位于实际情况和需求之间，使实际情况转换为需求所需的模样。

Adapter模式有以下两种：

- 类适配器模式（使用继承的适配器）
- 对象适配器模式（使用委托的适配器）

### 什么时候使用Adapter模式

将，现有的已经经过充分测试的类，进行适配，生成新的类以满足新的需求。



## Template Method（模版方法）方法

在父类中确定处理的流程，然后将具体处理交给子类。

在父类中定义处理流程的框架，在子类中实现具体处理的模式称为TemplateMethod模式。

模版方法类中的模版方法一般被声明为`final`,用于不允许被子类覆盖。



## Factory Method（工厂方法）模式

将Template Method模式用于实例的生成就是Factory Method模式。

抽象类不能用`new`生成实例。

建议在程序注释和开发文档中记录所使用的设计模式的名称和意图，以免后续维护人员做出违背设计者初衷的改动。

分析设计模式的时候，主要是分析多个类和多个接口之间的相互关系，不应当只看其中的某个类。



## Singleton（单例）模式

确保任何情况下都绝对只存在一个实例的模式被称为Singleton模式。

Singleton模式需要确保不因人的失误出现意外情况，不能靠通过口口相传或者注释的方式要求其他所有人自觉做到不实例化出多个实例。



## Prototype模式

通过复制生成实例：不根据类生成实例，而是通过实例生成新实例。

可以用`java.lang.Cloneable`接口

面向对象编程的目标之一：作为组件复用。

一旦在代码中出现要使用的类的名字，就无法与该类分离开来，也就无法实现复用。即使没有Java文件也能复用该类才是关键。



## Builder（构造器）模式

组装复杂的实例。

模式中的角色：

- Builder（建造者）
  - 负责定义用于生成实例的接口
- ConcreteBulder（具体的建造者）
  - Impl了Builder接口的具体的类。
- Director（监工）
  - 负责使用Builder角色的接口来生成实例。其只调用Builder角色中被定义的方法。
  - 一般有个`construct`方法用于生成实例。

> 只有不知道子类才能替换。
>
> 正因为不知道才能够替换，正因为可以替换，组件才具有高价值。



## Abstract Factory（抽象工厂）模式

> 将关联零件组装成产品。
>
> 抽象工厂的工作是将“抽象零件”组装成“抽象产品”。
>
> “抽象”这个词的含义是指“不考虑具体怎样实现，而是仅关注接口”
>
> 我们不关注零件的具体实现，而是只关心接口。我们仅使用接口将零件组装成为产品。

Abstract Factory中的登场角色：

- AbstractProduct（抽象产品）
  - 负责定义AbstractFactory角色所生成的抽象零件和产品的接口。
- AbstractFactory（抽象工厂）
  - 负责定义用于生成抽象产品的接口

java的文件夹名称全小写。



## Bridge（桥接）模式

设计时，将**类的功能层次结构**和**类的实现层次结构**分离，然后使用Bridge模式将二者连接起来。

层次结构：类的继承结构。

### 类的功能层次结构：

继承的目的是为了增加功能而产生的层次结构。

### 类的实现层次结构

- 父类通过声明抽象方法来定义接口
- 子类通过实现具体方法来实现接口

> AbstractClass
>
> - ConcreteClass1
> - ConcreteClass2

### 实现方式

通过在**功能层次的类**中增加一个**实现层次结构的类**的成员属性，需要使用相关方法时，委托该成员属性调用方法实现。

注意，两个层次不源自同一个接口或类，即**实现层次结构的类**的祖先接口和**功能层次的类**祖先类之前没有继承和实现关系。

> 编写子类的时候要先确认自己的意图：我是要增加功能呢，还是要增加实现呢？



## Strategy（策略）模式

整体的替换算法。

