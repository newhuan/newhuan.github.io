<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <title>Unix编程艺术——笔记</title>
    <link rel="stylesheet" href="https://newhuan.github.io/css/app.css">
    <script src="https://newhuan.github.io/js/element.js"></script>
</head>
<body class="body body-article">

    <div class="full-container">
        <div class="container">
            <div class="content">
                <h1 class="title">Unix编程艺术——笔记</h1>
                <h3 class="date">20170108</h3>
                <div class="clearfix typo">
                   <p>编程  是一件快乐的事
                   </p><p>KISS原则：keep it simple stupid
                   </p><p>一个程序只做一件事，并做好。
                   </p><p>编程的核心是数据结构而不是算法
                   </p><p>spot：寻找一种数据结构，使得模型中的形态和真实世界系统的状态能够一一对应
                   </p><p>尽量使用简单的算法配合简单的数据结构
                   </p><p>宽收严发：对接收的东西要宽容 对发送的东西要严格，不需要的消息也绝不丢弃，绝不增加无用的数据
                    宽进严出：尽可能宽松的接收输入格式，给出结构严谨的输出格式
                   </p><p>小即是美，在确保任务的基础上，程序功能尽可能的少
                   </p><p>看到该做的就去做：如果不确定什么是对的那么就保证只做最少量的工作，确保任务完成就行，直到明白什么是对的
                   </p><p>要编写复杂软件又不至于一败涂地的唯一方法，就是用定义清晰的接口把若干简单模块组合起来，如此一来多数问题就只会出现在局部 那么还有希望对局部进行优化而不至于牵动全身
                   </p><p>先定义接口，然后编写简要注释，最后写代码
                   </p><p>重构：改变代码的结构和组织，而不改变其外在行为
                   </p><p>模块内单个函数不要太大，如果不能用一句话描述一个函数与其调用程序之间的约定，这个函数可能太大了
                   </p><p>不要被先入之见误导，忘记那些不存在的限制（三条线链接四个点问题）——没有人规定，一定要怎么样，一定不能怎么样！
                   </p><p>文本化
                   </p><p>尽量避免特殊情况 特殊情况是bug的温床
                   </p><p>产生特殊情况 要认为是设计出了问题而修改设计 而不是为特殊情况专门设计语法
                   </p><p>保证用户的操作都是可逆的无损的 给用户以不断尝试而不会损坏数据的信心
                   </p><p>选择简单的算法=>减少bug出现的几率 也使维护者容易理解
                   </p><p>如果能实际上预测到程序的全部或者大部分情况，并建立简单的心理模型，那么程序就是透明的，因为可以看透机器究竟在做什么

                   </p><p>接口的主题：与其他程序通讯的前瞻性设计&&最小立异原则：少来标新立异，目的是为了减少用户在使用接口时必须的学习过程
                   </p><p>接口的特性：简洁，易用，透明，脚本化能力，表现力
                   </p><p>确认提示应该尽可能的用在用户很有可能给出'不不不'的情况，而不是一直是 '是是是'
                   </p><p>最好的优化是更好的设计
                   </p><p>降低算法复杂度 所有的O（n^2）及其以上复杂度的算法都是不好的 最好想办法降低复杂度
                   </p><p>尽可能的简单 但是别简单过头了
                   </p><p>只有证实了其他方法行不通的时候（尝试分解问题失败的时候）才去写庞大程序
                   </p><p>复杂度来源：程序员理解并调试程序的困难程度，用户对程序界面复杂度的承受能力，代码量
                   </p><p>将时间花在设计质量上，而不是低层次的设计细节上，尽可能自动化一切
                   </p><p>不要重复发明轮子，能用其他程序完成的工作就不要自己重复写（你也不一定比别人写得好）
                </p><p>论打破约定俗成：改变约定俗成的规则会增加用户和未来维护者的磨合成本，如果一定要打破规则，那就放手去做，但是要确信自己完全知道为什么要这么做，打破规则之前确保所有常规方法都理所当然的失败了，同时保证遵循补救原则给出正确的反馈</p>
                </div>
            </div>
        </div>
    </div>

</body>
</html>