# 软件分层方式

分层的设计可以简化系统设计，让不同的人专注做某一层次的事情

再有，分层之后可以做到很高的复用。比如，我们在设计系统 A 的时候，发现某一层具有一定的通用性，那么我们可以把它抽取独立出来，在设计系统 B 的时候使用起来，这样可以减少研发周期，提升研发的效率。

最后一点，分层架构可以让我们更容易做横向扩展。如果系统没有分层，当流量增加时我们需要针对整体系统来做扩展。但是，如果我们按照上面提到的三层架构将系统分层后，就可以针对具体的问题来做细致的扩展。

说了这么多分层的优点，那么当我们要做分层设计的时候，需要考虑哪些关键因素呢？在我看来，最主要的一点就是你需要理清楚每个层次的边界是什么。

## MVC

也就是将用户视图和业务处理隔离开，并且通过控制器连接起来，很好地实现了表现和逻辑的解耦

### Model: 模型层

指业务模型，包含数据模型。

各种业务逻辑的定义都在这一层，在这一层维护业务模型。



### View:视图层

指各种页面，类似HTML，是用户请求的来源。



### Controler：控制器

把来自视图层的请求和模型层的处理逻辑关联起来。

同时包含权限控制。



## SpringMVC

SpringMVC中的DispatcherServlet会根据RestControler中的url和处理方法构建的HandlerMapping找到和请求的url匹配的Handler方法，并调用Handler方法，并法Handler方法的返回渲染组装后，作为请求的返回内容。



## 表现层、逻辑层和数据访问层

另外一种常见的分层方式是将整体架构分为表现层、逻辑层和数据访问层：

表现层，顾名思义嘛，就是展示数据结果和接受用户指令的，是最靠近用户的一层；逻辑层里面有复杂业务的具体实现；数据访问层则是主要处理和存储之间的交互。

解决什么问题？设计思想？适用于哪一类业务？

这是在架构上最简单的一种分层方式。其实，我们在不经意间已经按照三层架构来做系统分层设计了，比如在构建项目的时候，我们通常会建立三个目录：Web、Service 和 Dao，它们分别对应了表现层、逻辑层还有数据访问层。

![img](../../../../pictures/arch-3.jpg)

## 阿里分层规约

![img](../../../../pictures/note/ali-arch.jpg)



- 终端显示层：各端模板渲染并执行显示的层。当前主要是 Velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。

- 开放接口层：将 Service 层方法封装成开放接口，同时进行网关安全控制和流量控制等。

- Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。

- Service 层：业务逻辑层。

- **Manager 层：通用业务处理层。这一层主要有两个作用，其一，你可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的接入；其二，你也可以在这一层封装对第三方接口的调用，比如调用支付服务，调用审核服务等。**
  - 看起来主要是对Service层内的通用部分做了复用

- DAO 层：数据访问层，与底层 MySQL、Oracle、HBase 等进行数据交互。

- 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。

在这个分层架构中主要增加了 Manager 层，它与 Service 层的关系是：Manager 层提供原子的服务接口，Service 层负责依据业务逻辑来编排原子接口。

以上面的例子来说，Manager 层提供创建用户和获取用户信息的接口，而 Service 层负责将这两个接口组装起来。这样就把原先散布在表现层的业务逻辑都统一到了 Service 层，每一层的边界就非常清晰了。



比方说，单一职责原则规定每个类只有单一的功能，在这里可以引申为每一层拥有单一职责，且层与层之间边界清晰；迪米特法则原意是一个对象应当对其它对象有尽可能少的了解，在分层架构的体现是数据的交互不能跨层，只能在相邻层之间进行；而开闭原则要求软件对扩展开放，对修改关闭。它的含义其实就是将抽象层和实现层分离，抽象层是对实现层共有特征的归纳总结，不可以修改，但是具体的实现是可以无限扩展，随意替换的。



## 架构

首先是程序员 / 代码的结构性，这是软件结构性的最小起点，指的是每个程序员提交的代码在设计上的一致性。代码是所有上层软件结构性的最终载体，也是现实世界中所有结构化决策，最终具象化到软件世界中的呈现方式。这种一致性的主要价值，在于代码的可维护性，以及代码易于变更、升级迭代和扩展的性质。

然后是兼职架构师 / 横向问题的解决方案。这是第一层抽象，也就是在多个代码模块中间共享同一个横向问题的解决方案，让横向问题的解决方案在多个模块中是一致的。这种一致性往往来自一个简单的组织抽象，也就是在多个代码模块中共享同一个有解决横向问题的兼职架构师。这种一致性的价值，就在于更低的实施成本和更高质量的解决方案。

接着是跨域架构师 / 整体的解决方案。这是第二层抽象，指的是在多个领域之间维持整个解决方案的结构性。这种结构性体现了设计理念、数据模型、信息交互的一致性，最终将促进整个领域的结构性。这种结构性的价值，就在于让整个领域的软件质量更高、可维护性更好、更容易升级迭代。

接下来是总架构师 / 决策原则。这是第三层抽象，指的是在软件架构相关投入上的决策原则，在整个企业内具有一致性。也就是说，总架构师的存在是为了保障企业在不同层次、不同领域上的软件投入的决策原则是同质的。这个决策原则，就是最大化技术的长期增值。程序员、兼职架构师和跨域架构师，这三个角色都是在依照同一个假设来工作的。这个假设就是更高层次上的软件系统的结构性，会带来更好的外部适应性。这三个层次，按照从高到低的排序，依次是跨领域的、横向问题上的、代码层面上的一致性。



这些性质似乎是多多益善的。但事实上，实施这些假设需要投入研发成本、时间成本、甚至是机会成本才能完成。而一个公司中的研发资源是有限的，那么首先应该在哪个领域中的哪个层次投入呢？是否应该现在就投入呢？这就是要由总架构师通过最大化外部适应性的原则，来做出优先级决策的内容。此外，他也要为这些决策应该带来的预期商业回报和实际结果的一致性负责。

最后是 CTO／企业生存优先的理念。这是最高层次的抽象，指的是理念上的一致性。我们在课程中提到了，从 CTO 的视角看，企业在决策理念上应该和 CEO 视角保持一致，也就是最大化企业的生存。在这个理念之下，企业的资源投入，不论是在技术、运营，还是市场，都应该和最大化生存这个目标保持一致。技术这个职能没有特殊性，仅仅是其中一个手段。

需要强调的是，这个理念背后是公平的价值观。而这个理念对整个公司来说都是极端对称的，是公平意志的体现。而这种理念一致性的价值，就是最大化企业的长期生存。

你可能会质疑，CTO 这种终极的理念一致性，似乎已经超出了软件架构设计这个范畴。为什么我作为一个一线的工程师还需要学习呢？

在日常的架构决策中，你不一定会用到 CTO 这种视角。但是也要知道，寻求最大化生存这个理念，一定会体现在架构设计的方方面面，包括如何保证一个软件模块能够被快速变更，而不影响到整体的稳定性和结构性。其次，我们在课程里不止一次提到过理念的一致性和规则的公平性。比如规则本身的对称性，对规则而不是权威的尊重，对架构师活动中共识的建设、决策信条的建设和迭代优化，等等。你肯定已经意识到了，这种理念的一致性，不仅对于 CTO 这个角色来说很重要，其实对于企业中每个职能的每个行动都至关重要。这种理念的一致性，与我们在第 14 讲里提到的相信过程正义如出一辙。也就是说，这种理念一致性是渗透在日常行为中的，在职业生涯中是连续的，是和决策的规模无关的（Scale-Invariant）。小到一个团队内的设计评审和季度评优，大到整个企业的管理，保持理念的一致性，能让最终决策为大多数所认同，并被更高效彻底地执行。

能力成长的关键，在于发现和跨越障碍

































































