### 程序员的修炼之道（第二版）总结

2021-06-05

你要为自己的人生做主，精心营造，与人分享，为之喝彩，好好享受把。

#### 第二版看了之后新的收获主要有

1. 什么是优秀的设计(价值观，指导方法)：更易于修改：ETC (Easier To Change)
2. 版本管理能用尽量用
3. 项目术语表是个好东西
4. 用户并不真的知道自己的需求是什么，程序员的工作就是帮助客户理清楚真正的需求是什么
5. 提问，澄清，决策和演示。讨论，做笔记，思考，编码的同一时刻提问和讨论
6. 按照代码期待的样子来组织团队
7. 敏捷有关你如何做事，谈的是对变化的响应：弄清楚你在哪里，朝想去的方向迈出有意义的最小一步，评估在哪里终结，把弄坏的东西修好
8. 不持续对流程做实验的团队不是敏捷团队：持续对流程做实验
9. 版本控制，测试和自动化
10. 团队的工作：旧系统的维护，流程的反思和精炼，实验新技术，学习和提升技能,即时的沟通，组织全功能的团队，将一切自动化
11. 环境不同需要应用的方法不同，创立方法的团队也会在演进中更新方法，变通、更新、与环境俱进才是方法生效的原因（调整）
12. 版本控制，回归测试，完全自动化
13. 使用版本控制来驱动构建、测试和发布
14. 取悦用户，用户只是想要在预算范围内解决遇到的业务问题，而不是需要代码。
15. 在生产环境尽可能多的收集信息
16. 复用的追求就是，复用，灵活拓展，不付出额外的东西：接口和协议，委托，mixin
17. 解决问题的前提是找到问题的所有环境变量，找到真正的限制是什么
18. 维持小而稳定的团队
19. 测试追求的时状态的覆盖率，而不是代码的覆盖率
20. 自动化非常重要，能自动做的事情让机器自动做（搞清楚机器做了什么）
21. 程序员被老板要求做坏事也是会被追责的
22. 传达信息的过程才算交流：对方的反应即沟通的意义
23. 日记本
24. 尽早崩溃
25. 通过分析工作流来提高并发性
26. 测试的主要收益来自于思考和编写测试期间，这期间会如何思考问题
27. 感觉有问题或者有什么地方不对的时候，给自己一点时间，让大脑自我组织。



#### 重温已经看过的，仍觉得很有价值:

1. 做推动变革的催化剂
2. 永远留意着大局，持续不断的审视你身边发生的事情，而不要只专注个人正在做的事情
3. 安排时间学习一些看起来有趣的新东西，只有为此加班才是合理的。
4. 不要害怕承认无知和错误
5. 我现在不知道，但是我会去搞清楚
6. 项目中你觉得就这样吧的代码，不要让他就这样下去。
7. 交流：根据听众的类型挑选风格和叙述方式，理清楚自己要说的，选择时机，漂亮的格式，初稿的时候让听众参与进来收获反馈，听别人说（否则别人也不会听你说），记得回复别人
8. 把代码和文档绑在一起
9. 不要重复
10. nothing is final, nothing is static,也不要依赖自己无法控制的东西
11. 不要恐慌
12. 小步前进，检查反馈，在推进前不断调整，反馈的频率就是速度限制
13. 宽松灵活的代码
14. 解耦让变更变得容易（ETC）
15. 不要链式调用不可靠的东西
16. 编程应该深思熟虑：现在能工作了，最好不要碰这块-> 不要产生这样的想法，找到恰好能用的答案和找到正确的答案不是一回事
17. 最快的算法并不总是最适合的代码
18. 批评要针对代码，而不要针对人。“我们来看看这块”听起来比“你搞错了”好得多
19. 观点不同不是错误，倾听他人的观点并试着理解
20. 频繁的进行回顾，为下一次做好准备
21. 不要一个人埋头钻进代码中



#### 有关学习和投资自己：构建知识组合

1. 定期投资：安排固定的时间和地点构建
2. 多样化：知道的越多，自己的价值就越大：至少要知道目前工作中特定技术的来龙去脉，然后更深入一步。熟悉的技能越多，越能适应变化
3. 风险管理：不要把鸡蛋都放在一个篮子里
4. 低买高卖：在一项新兴技术变得流行之前就开始学习
5. 重新评估调整：技术更新换代很快，流行也是个轮回
6. 目标：每年学习一门新语言，每个月读一本技术书，非技术书也要读（软技能很硬核），上课，加入本地的用户组和交流群，尝试不同的环境，与时俱进
7. 最后：持续投资，进入舒适区就要再进一步

ps: Clojure,Elixir,Elm,F#,Go,Haskell,Python,R,ReasonML,Ruby,Rust,Scala,Swift,Typescript



#### 关于批判性思维，接受之前先问几个问题

1. 至少问五次为什么
2. 谁从中受益
3. 上下文是什么，背景是什么，后果是什么
4. 什么情况下可以生效
5. 为什么是这个问题



#### 关于估算：

1. 时间单位：1-15天，3-6周，8-20周（月），20+周（说出估算前再好好想想）
2. 估算的时候可以问问已经做过的人
3. 开始估算前，先搞清楚需要估算的问题的上下文
4. 将整个问题建立模型，拆分成组件，确定参数，然后计算答案
5. 记录自己的估算，如果估算有误差，找到原因在哪
6. 推进过程中，根据实际进度及时更新进度表
7. 暂时估算不出来：我等下答复你



#### 如何深思熟虑的编程

1. 时刻注意你在做什么
2. 考虑如何向一个更初级的程序员详细解释一下代码
3. 不要构建自己没有完全掌握的系统，如果你不知道它为什么能用，就不知道它为什么会出错
4. 按计划推进
5. 只依赖可靠的东西：如果不知道某件事是否可靠，就做最坏的打算
6. 将假设文档化
7. 不要猜，实际去试一下
8. 为你的精力投放安排一个优先级
9. 不要让现有的代码支配未来的代码，确保所有代码在不再适用的时候都是可以替换的



#### 关于重构

1. 重构有规范，不要随意为之
2. 重构时，保证外部行为不表，不要添加功能
3. 需要有良好的单元测试作为验证代码行为的保证
4. 没时间重构？现在不重构以后就要投入更多的时间来解决问题。
5. 尽早重构，经常重构
6. 重构的核心是重新设计
7. 采取简短而慎重的步骤
8. 要有良好的回归测试



#### 关于安全：

1. 不要自己做加密
2. 尽早打上安全补丁
3. 保持代码简洁，让攻击面最小
4. 不要限制密码长度（256位最佳）
5. 不要截断用户的密码
6. 不要限制特殊字符
7. 不要向未经认证的用户提供密码提示
8. 不要禁用粘贴功能：会促使用户创建更简单的密码
9. 不要强制用户定时修改密码
10. 不要强加其他组合规则



#### 关于需求

1. 沟通需求的过程就是解释客户所说的话，并向他们反馈其中的含义
2. 没有人确切的知道自己想要什么
3. 梳理需求就是帮助别人理解他们想要什么
4. 需求是从反馈循环中学到的，而不是收集来的：你是不是这个意思，是不是更像这样
5. 客户从不阅读规范
6. 需求文档是为开发人员写的
7. 以用户场景的形式描述需求
8. 需求就是需要的东西，不是架构，需求无关设计，也不是用户界面
9. 维护一张项目术语表：保证每个人用相同的名称来称呼相同的事务。
10. 不要害怕，大胆的提出改变需求的建议



#### 东北乱炖：

1. 有限状态机：所有的状态和状态间所有存在的变换和变换结果

2. 观察者默认：注册，发布/订阅
3. tail命令相对的是head命令：取文件尾/头的内容
4. find . -type f | xargs wc -l | sort -n | tail -6 | head -5
5. wc -l  计算文件行数
6. find . -type f  向标准输出写入当前目录及其以下的所有文件
7. 策略一般一个问题只有一种策略处理，责任链是链式调用
8. 计算机科学中只有两件难事：缓存失效和命名
9. 注意力分散的人在解决复杂问题的时候比有意识的人做的更好：先放空自己，晚一点再继续



#### 可以咀嚼：

1. 自责中往往有种奢侈，我们自责时，总觉得别人无权再责备我们
2. 心中要有一个目的地，否则就会原地打转
3. 亚历山大大帝的绳节，三线四点问题，网线框事件：一些看起来好像很明显的约束条件并非真的约束条件，找到真正的边框和约束在哪里



#### 拓展书籍：

人月神话，人件，设计模式：可复用面向对象软件的基础，设计模式，程序设计实践



#### 拓展方法

Scrum,极限编程，看板，精益技术
