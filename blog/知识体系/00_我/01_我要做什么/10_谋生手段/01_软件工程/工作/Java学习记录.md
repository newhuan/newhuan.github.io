# Java学习记录

### 20200524

### 导论

Java中所有的类最终都继承自Object

堆栈(stack)：编译器可以确定其上对象的生命周期. 用于存放对象引用，基础类型值，局部变量等

堆(heap)：编译器无法确定其上对象的生命周期. 实际存放对象的内容

Java=>在堆栈(stack)上创建对象引用，在堆(heap)上创建对象（new）=>垃圾回收

寄存器：保存函数参数，堆栈：保存对象引用和基本类型数据，堆：保存对象，常量存储：代码内部

class的成员属性在class初始化(new)的时候会赋默认值

### 初始化和清理

static方法内部不能使用this

垃圾回收：分代，停止-复制，标记-清扫，内存块=>多种策略混合=>ZGC

"Class初始化顺序：1. 定位class文件 2.载入class文件，创建一个Class对象，初始化静态对象(static) 3. new Class的时候在堆上分配足够的存储空间，清零此处存储空间（这会自动的给所有基本类型数据设置了默认值，引用则被设置为null）

4. 从上到下执行字段定义处的初始化动作 5. 执行构造器

初始化子类的时候，先自底（基类）向上（子类）初始化static属性，然后自底向上初始化成员＋调用构造函数"

### Access Control

protected => 子类和包内类可访问，其余用户不可访问

### 继承

抽象方法，抽象类，接口

只能extends一个基类（可以是抽象类），可以implements多个接口（interface可以extends多个interface）

适配器模式＝>将A接口转换成B接口，使不兼容的类可以一起工作

OutClass.InnerClass =>　内部类

内部类可以访问其所属的外部类的所有属性，包括私有属性

每个内部类都能独立的继承自一个（接口）的实现，无论外围类是否继承了某个(接口的)实现 => 使多重继承变得完整。

内部类是面向对象的闭包：闭包是一个可调用对象，它记录了一些信息（外围类的引用），这些信息来自于创建它的作用域

### 容器

迭代器统一了对容器的访问

队列：只能一端进，另一端出

栈：后进先出

HashSet:速度最快

TreeSet: （红黑数）维持元素顺序（升序存储）

LinkedHashSet: 维持元素插入顺序

Array.asList生成的List不能做改变其容量的操作=>会抛出异常

HashMap: 容量(bucket数量)，初始容量，尺寸(当前存储的项数)，负载因子（尺寸/容量）（默认0.75,超出之后需要再散列(哈希扩容)）

### 异常

不论如何finally总会执行，不论try catch里是return,break,continue

catch语句，如果程序找到匹配的异常处理，就不会再继续查找。派生类可以匹配其基类的处理程序

### 字符串

循环拼接字符串要用StringBuilder => 否则JVM会在每个循环体里创建StringBuilder做字符串拼接

正则replace处理函数 => matcher.appendReplacement(); matcher.appendTail();

### RTTI

RTTI: Runtime Type Identification：　运行时类型信息：RTTI（类型转换＋instanceof+Class对象） + 反射（泛型类型擦除）=> 在运行时，识别一个对象的类型

反射:getFields,getMethods,getConstructors

RTTI: 编译器在编译时打开和检查.class文件

反射：.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件

不要太早关注程序的效率问题，先让程序能运行起来，再考虑他的速度

### 泛型

Java泛型：告诉编译器想使用什么类型，然后编译器帮你处理一切细节

泛型类和泛型方法：能用泛型方法就不要用泛型类，static方法无法访问泛型类的类型参数，所以如果想static方法需要泛型能力，就必须使其成为泛型方法

基本类型(int.char)无法作为类型参数

在泛型代码内部，无法获得任何有关泛型参数类型的信息，不能使用转型，instanceof和new,只能把这个类型当成一个Object来看

<T extends Foo & Bar>(class(Foo)必须放在最前面，之后是interfaces)

<? super MyClass> : MyClass及其基类

<? extends MyClass>: MyClass及其子类

上界，下界都是针对使用时候传递的类型参数的限制

<?> 无界通配符：　表示某种特定类型

泛型的问题

1. 基本类型不能作为类型参数
2. 一个类不能实现同一个泛型接口的两种变体 => 类型擦除之后，两个变体会变成相同的接口
3. 转型和instanceof不会有任何效果
4. 无法重载　＝> 类型擦除
5. 基类劫持了接口

策略设计模式：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。将这些算法封装成一个一个的类（实现了同一个接口），任意地替换。

### 数组

数组：可以通过索引访问它们的元素，但是它们的尺寸不能改变

数组：效率，类型（以前可以持有类型，但是泛型出现之后这个优势就没了），保存基本类型（泛型＋自动拆箱，自动装箱）　＝> 硕果仅存的优点：效率

对象数组保存引用，基本类型数组直接保存基本类型的值

"compare：返回负值=> V1 < V2,返回0 => V1 + V2, 返回正值=> V1 > V2 => 最红得到从"小"到"大"的一个排序后的结果"

使用容器，泛型容器，少用数组，尽量别用

### I/O

nio: 通道+缓冲器，缓冲器从通道中获取数据，使用数据的时候只和缓冲器打交道

映射文件访问

"装饰器模式：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。"

装饰器模式：关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

新增的Path和Files类

### enum

static import可以将enum实例的标志符带入当前命名空间，所以无需再用enum类型来修饰enum实例

在interface中添加实现了改interface的enum可以实现enum分组

EnumSet和EnumMap: 元素的次序由enum实例定义的次序决定，所以查找元素的时候只要找对应位置是否为true就好，飞快

职责链设计模式：当请求到来时，遍历一个由不同解决方案组成的职责链，直到某个解决方案能处理该请求

### 并发

多线程基本困难：保证共享资源不会同时被多个任务访问

Java线程机制：抢占式，定期中断线程，切换到另一个线程

Runable,Callable

异常不能跨线程传播

守护/后台线程（daemon）：未执行完的守护线程会在非守护线程全部执行完毕后被kill然后结束程序

join(): 挂起当前线程，直到join的线程结束再恢复

原子性: 不能被线程调度机制中断的操作，一旦操作开始，就一定会在可能发生的上下文切换发生之前完成，操作没有中间状态，任务在发生时没有中断的可能性

并发模式解决线程冲突：序列化访问共享资源

锁+synchronized

volatile：对volatile的修改会立刻写到主存而非cpu缓冲区（读操作发生在主存中）

线程状态：新建(new)，就绪(runnable),阻塞(Blocked),死亡(Dead)

线程处于阻塞状态（wait,sleep,等待输入输出完成，等待锁）或试图执行一个阻塞操作，此时设置这个线程的中断状态会抛出InterruptedException

线程协作：wait + notify + notifyAll或者用Lock的Condition：await, signal,signalAll

总是用while循环包裹判断线程是否wait的condtion语句

同步队列

死锁：任务之间相互等待的连续循环，导致没有线程可以继续

哲学家就餐问题：所有哲学家围成一圈，每个人都在等待右手边的筷子可用

死锁条件：1. 互斥条件，即有资源不能共享2. 有任务已经持有一个资源，同时在等待一个其他任务持有的资源 3. 资源不能被抢占 4. 必须有循环等待

破除四个条件之一就能破除死锁

sleep不会释放锁，wait会释放锁

线程池

保持一个观点：你实际上没有控制线程的能力

可重入：任何时刻被中断，转入OS调度，返回控制时不会发生错误

同步集合:ConcurrentHashMap,ConcurrentHashSkipListMap,ConcurrentHashSkipListSet,ConcurrentHashLinkedQueue

Executor: 整合Thread

### Stream

stream,parallelStream => 顺序流和并发流

只要在终结方法执行时，流处于并行模式，那么所有中间流操作都将并行化

只有对已经位于内存中的大量数据执行大量操作的时候才应该使用并行流

### 单词

recursion:递归

channel:通道/渠道

flip　翻动

transient: 瞬时

concurrent:同时，并发

daemon:守护程序

volatile: 易变的

predicate　断言，谓语

assert 断言

remedy: 补救

reentrant:可重入