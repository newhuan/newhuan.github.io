# Unix编程艺术——书摘（二）

### 20170108

unix哲学

kiss

keep it simple stupid

一个程序只做一件事，并做好。程序要能写作。程序要能处理文本流，因为这是最通用的接口

编程的核心是数据结构而不是算法

尽量使用简单的算法配合简单的数据结构

原则

模块原则：使用简洁的接口平和简单的部件

清晰原则：清晰胜于机巧。使用简洁清晰的编程语言，不要为了一丁点的性能优化使用大量晦涩难懂的语句

组合原则：设计时考虑拼接组合

分离原则：策略同机制分离，接口同引擎分离

简洁原则：设计要简洁，复杂度能低则低

吝啬原则：除非别无他法，不要编写庞大的程序

透明性原则：设计要可见，以便审查和调试

健壮原则：健壮源于透明与简洁

表示原则：把知识叠入数据以求逻辑质朴而健壮

通俗原则：接口设计避免标新立异

缄默原则：如果一个程序没什么好说的，就沉默

补救原则：出现异常时，马上退出并给出足够的错误信息

经济原则：宁花机器一分，不花程序员一秒

生成原则：避免手工hack，尽量编写程序去生成程序

优化原则：雕琢前先要有原型，跑之前先学会走

多样原则：绝不相信所谓不二法门的断言

拓展原则：设计着眼未来，未来总比预想来的快

宽收严发：对接收的东西要宽容 对发送的东西要严格

过滤时不必要丢弃的信息绝对不丢

小即是美，在确保任务的基础上，程序功能尽可能的少

看到该做的就去做：如果不确定什么是对的那么就保证只做最少量的工作，确保任务完成就行，直到明白什是对的

编程 是一件快乐的事

模块化

要编写复杂软件又不至于一败涂地的唯一方法，就是用定义清晰的接口把若干简单模块组合起来，如此一来多数问题就只会出现在局部 那么还有希望对局部进行优化而不至于牵动全身

先定义接口，然后编写简要注释，最后写代码

紧凑性

常用用户通常不需要操作手册

让你乐于使用，不会在你的想法和工作之间格格不入

正交性：任何操作均无副作用

重构：改变代码的结构和组织，而不改变其外在行为

spot：寻找一种数据结构，使得模型中的形态和真实世界系统的状态能够一一对应

提高紧凑性：围绕 解决一个定义明确的问题 的强核心算法组织设计 避免臆断和捏造

不要被先入之见误导，忘记那些不存在的限制（三条线链接四个点问题）

自顶向下和自底向上

胶合层：自顶向下和自底向上冲突时进行抗阻匹配，特别容易出问题，所以要尽可能的薄

你必须知道你在做什么

尽可能少的全局变量

一个模块的最佳物理行在400-800行之间

模块内单个函数不要太大，如果不能用一句话描述一个函数与其调用程序之间的约定，这个函数可能太大了

API入口，类的方法，数据结构成员 都不要超过七个

文本化

透明性

如果能实际上预测到程序的全部或者大部分情况，并建立简单的心理模型，那么程序就是透明的，因为可以看透机器究竟在做什么

不要让调试工具仅仅成为一种事后追加或者用过之后就束之高阁的东西 他们是通往代码的窗口

让UI可以访问细节又不让他们太显眼

别人能读懂这种设计吗？

要追求代码的透明 最有效的方法就是不要在具体操作的代码上叠放太多的抽象层

最大静态深度(用户需要完成一个操作的操作数)要小 最好不大于四

尽量避免特殊情况 特殊情况是bug的温床

底层细节可以被隐藏但是不能不可访问=>程序要灵活

保证用户的操作都是可逆的无损的 给用户以不断尝试而不会损坏数据的信心

文本化器：在可编辑的文本格式和二进制格式之间来回进行无损转换

如果作者以外的人能过顺利的理解和修改软件 那么这个软件就是可维护的

透明+可显=>可维护

选择简单的算法=>减少bug出现的几率 也使维护者容易理解

配置

能自动监测完成的配置就不要让用户费神

能用其他程序完成的任务就不要再添加程序的复杂度

添加一个功能前想想能不能用其他的方法完成这个需求而不必增加程序的复杂度

接口

一个程序的接口就是改程序和用户以及其他程序的通讯方法总和

两个主题

与其他程序通讯的前瞻性设计

最小立异原则

少来标新立异

接口的标新立异往往把精力放到了接口本身而忽视了接口的任务

要发现那些用户已知程序和自己程序之间的功能相似性，然后效仿已知接口的相关部分

接口设计者在为用户设想的时候总是不自觉的聪明过头

如果可能尽量把接口功能委托给用户熟悉的程序完成

目的是为了减少用户在使用接口时必须的学习过程

简洁，易用，透明，脚本化能力，表现力

简洁：一个事务处理需要的动作时间和复杂度有较低的上限

表现力：接口可以触发相当广泛的行为

易用性：用户完成操作需要记忆的东西越少越好

如果能实际上预测到程序的全部或者大部分情况，并建立简单的心理模型，那么程序就是透明的，因为可以看透机器究竟在做什么

脚本能力：程序能很容易的被其他程序调用

过滤器模式

宽进严出：尽可能宽松的接收输入格式，给出结构严谨的输出格式

不需要的消息也绝不丢弃

绝不增加无用的数据

长时间操作提供进度条，不要杂乱的让GUI弹出提示信息

确认提示应该尽可能的用在用户很有可能给出不不不的情况，而不是一直是是是

优化

最好的优化是更好的设计

先估量 后优化

保持代码简单短小

降低算法复杂度 所有的O（n^2）及其以上复杂度的算法都是不好的 最好想办法降低复杂度

永远不要把核心数据结构和时间关键循环跑出缓存

减少时延

对可以共享启动开销的事物进行批处理

允许事物重叠

缓存

复杂度

尽可能的简单 但是别简单过头了

来源

程序员理解并调试程序的困难程度

用户对程序界面复杂度的承受能力

代码量

种类

选择复杂度

依赖于对目标的选择

本质复杂度

偶然复杂度

极简原则暗示：选择需要管理的上下文环境，并按照边界所允许的最小化方式构建程序

只有证实了其他方法行不通的时候（尝试分解问题失败的时候）才去写庞大程序

工具

将时间花在设计质量上，而不是低层次的设计细节上，尽可能自动化一切

性能分析软件

百分之90的运行时间花在10%的代码上 优化这10%

重用

不要重复发明轮子

按照规格说明编写，如果发现和规格说明不一样的返回 那么不是违反了规格就是发现了bug

last

语言和工具

开源运动

如何开源

展望未来

自由主题

question

在设计时考虑宽容性 而不是用过分纵容的实现来补救标准的不足

特殊情况

特殊情况是个坏消息

产生特殊情况 要认为是设计出了问题而修改设计 而不是为特殊情况专门设计语法

论打破约定俗成

改变约定俗成的规则会增加用户和未来维护者的磨合成本

如果一定要打破规则，那就放手去做，但是要确信自己完全知道为什么要这么做

打破规则之前确保所有常规方法都理所当然的失败了，同时保证遵循补救原则给出正确的反馈

机制而非策略