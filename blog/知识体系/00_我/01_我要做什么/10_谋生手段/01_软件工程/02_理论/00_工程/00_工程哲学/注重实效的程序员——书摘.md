# 注重实效的程序员——书摘

### 20161220

## 第一章 哲学

不要找蹩脚的借口，而是提供挽救的选择

在询问别人之前先想想自己的问法自己会怎么想，其实很多时候已经知道结果就不要浪费时间了

**遇到低劣的代码及时修正，不要让这段劣质代码成为整个项目崩溃的第一块多米诺骨牌，否则当你想修正的时候已经来不及了（参考破窗理论）

当启动显得困难时，自己做出一个力所能及的改变，展示给别人，让别人在已经成功的基础上继续添加，会让启动变得容易。 做变化的催化剂

时刻关注大环境的改变，时刻关注自身细微的改变

**使质量成为你需求的一部分，同时知道什么时候应该停止。保证质量（这是前提），保持节制

让用户参与你的需求分析

**知识资产

定期学习一些新知识

不断更新你的知识和经验

一专多能

也要注意技术以外的事物，不要让自己与世隔绝

努力寻求答案 不要搁置下来

学会判断听到或者看到的，批判性思维

询问别人之前最好组织好语言 这样可以节约双方很多时间 也会轻松很多

交流

在交流之前最好先弄明白自己想说什么，自己想说的这些能把自己所有的想法表述清楚吗？

明确受众，搞清楚他们关注 地方

选择合适的交流时机

根据不同的听众选择不同的交流风格

善于倾听

及时回复他人

**你怎么说和你说什么一样重要

## 第二章途径

不要重复你自己(不要有重复代码) 系统中所有的知识的解释都应该是单一的 无歧义的

欲速则不达

让复用变得容易

有耐心，注重开发者之间的交流

正交性

改变其中某项事物而其他事物不需要改变

消除无关事物间的影响

时刻为可能出现的意外做准备，确保自己不会受制于自己曾经做出的决定

牢记 计划始终在变化

曳光弹 => 先做出一部分 然后在已经成功的代码基础上进行添加 （不止这些，总结的不够）

？？制作原型（原型=>用完就丢）

？？领域语言 => 获取需求时先使用一些易于理解的语言进行写出流程 再把这种语言用编程语言实现

估算的时候慎重的选择估算结果的单位

估算时在你没有把握的时候最好寻找一个有过类似经历的人进行询问

建模时给最关键的组件最精确的数据

如果你在估算时得到一些非常奇怪的结果，不要轻易放弃他，因为如果你的计算是正确的 那么变得奇怪的原因就是你对模型的理解有错误！这是十分宝贵的

记录你的估算

被要求估算时的回答 => 我等会回复你！

## 第三章基本工具

？？（还是不理解，翻译的有问题吧）纯文本 => 由打印字符组成，人可以直接阅读和理解其含义

用纯文本保存知识

？？杠杆作用

（shell）使用命令的组合而不是图形界面，你将大幅提高你的效率，否则只能受制于提供图形界面工具的人

**用好并精通一种编辑器

源码控制 git、

调试

要修正问题 而不是指责

不要恐慌

思考是什么造成了你的那个bug

不要把时间浪费在‘那不可能’这个念头上，因为他不仅可能而且已经发生了

抵制只修正你看到的问题的强烈愿望

第一步 再现bug

调试时详细的理顺自己的思路有时会是一种好方法

？？select isn't broken

不要假定 证明他

？？学习一门文本操纵语言

代码生成器

## 第四章 偏执

按合约设计=>DBC => 给类添加前置条件？

DBC优点 => 迫使需求和保障的问题走到前台

设计软件时也要设计合约

当你的程序发生某些你认为绝对不可能发生的情况的时候，说明这个程序已经不可靠了，你最好尽快停止它，一个死程序的危害性要比一个生病程序的危害性低得多

如果他不可能发生，用声明确保他不会发生

不要以为测试完发布出去之后就可以删除bug检测声明

遇到可能出问题的地方时，用声明确保语句正确运行

只在异常可能出现的地方处理异常

对于调用的资源：finish what you start

## 第五章弯曲或折断

解耦

降低耦合

得墨忒耳法则=>某个对象的任何方法都应该是调用属于以下情形的方法：它自身，传入该方法的任何参数，他创建的任何对象，任何直接持有的组件对象

相应集=>类的方法直接调用的函数的数目

缺点：占用大量空间，降低性能，所以在要提升性能的时候，你可能需要加大耦合来使性能提升

时间换空间，空间换时间

？？元（meta）

把一般情况（抽象）写入程序，把具体情况（细节）写入元数据

适应性和灵活性

时间耦合

并发和次序

分析工作流（活动图）改善并发性

总是为并发进行设计

mvc

让视图和模型分开

？？黑板

## 第六章当你编码时

如果有什么看起来能工作，但是不知道为什么，确定它不是巧合

深思熟虑的编程

总要意识到你在做什么

不要盲目编程=>不要构建自己不完全理解的应用或者使用不熟悉的技术

按计划行事

依靠可靠地事

为你的假定构建文档

测试你的假定

为工作划分优先级，把时间花在最重要的工作上

不要让已有的代码支配未来的代码

靠巧合编程的典型（糟糕的想法）：：他看起来好像能工作了，最好不要画蛇添足。。。

算法估算

时间/空间复杂度

估算你算法的阶同时也要测试你的估算

代码剖析器

根据实际情况选择是否使用最优算法，最好的不一定总是最好的

重构代码

当你觉得代码不再合适的时候，不要对改动犹豫不决

时机

出现重复时

非正交的设计

过时的知识

性能

早重构，常重构

重构提示

不要试图在重构的时候添加功能

确保你拥有良好的测试

采取短小，深思熟虑的步骤，以避免长时间的调试

编写单元测试，并常常运行他们

测试你的软件，不然你的用户就得测试

不要用你不理解的向导代码====>不要靠巧合编程===>先弄懂，再写

## 第七章在项目开始前

不要搜索需求，挖掘它

需求，是对需要完成的某件事的陈述

找出用户为何要做特定事情的原因，而不是目前他们做这种事的方式

像用户一样思考，最好和他们一起工作一段时间（一周？）

不要拘泥于表示方式，只要有效的 都是好方法

抽象比细节活的更久

追踪需求的添加

创建专业用语的词汇表，保持项目中描述的一致性

**解决不了问题的一个原因可能是你太快的排除了潜在的解决方案

解决问题前先确定真正的约束是什么

面对棘手问题是，列出所有可能途径，不要排除任何东西，不论有多蠢。然后逐一解释为什么不可以采用某种途径，为什么不可以，你试过吗？

一定有更容易的办法

倾听反复出现的疑虑，等你准备好了在开始

当不确定是否应该启动的时候，去制作原型吧，确定是在单纯的拖延还是在等待准备好的时刻

对于某些事情，做 is better than 描述

太过详细的规范有时候是一种噩梦

使用形式方法，但是不要做形式方法的奴隶，需要时就用，记住自己才是方法的主人

## 第八章 团队

不要留破窗户

注意环境变化（时间标度，新特性，新环境）

保持交流

注意消除团队中的重复工作

按功能划分团队而不是工作，这样可以极大的减小某项环境改变其他成员受到影响的程度

兼顾成员的自由发挥

能自动完成的工作为什么不让他们自动完成呢

不要使用手工流程

误导人的信息比没有信息更糟1

重复庸常的工作交给计算机来做吧

测试

早测试 常测试 自动测试

要到通过全部测试 项目才算完成

单元测试 集成测试 性能测试 可用性测试 资源耗尽，错误和修复 验证和校验

回归测试 测试数据 演练GUI系统 对测试进行测试 彻底测试

通过蓄意破坏来测试你的测试

测试时注意要状态覆盖 而不是单纯的代码覆盖

不要把测试时间留到deadline，一旦产品代码出现 就应该测试

一旦测试抓住了一个bug，那么这次应该是最后一次抓住他

文档也是很重要的

注释应该是用来解释为何做某事，以及它的目的和目标

变量名要见名知意

？？文档？？？

温和的超出用户的期望，别太猛

‘管理’用户的‘期望’

最后 在你的作品上签名

目前可做

不断学习

编写时注重代码质量

注重交流

询问前先多想想几次

工具软件？

cygwin

uwin

perl power tools

emacs

vim

tip

IDE::集成开发环境

回归测试::修改了旧代码后，重新进行测试，以确定没有引入新错误

makefile=>GNU make命令