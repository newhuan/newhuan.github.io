# 技术原则

时间：2024-02-27

## 编码原则

### 面向对象模式编码原则

#### 本质理解

- 核心是**【抽象】**出概念，然后基于抽象的概念，把对抽象的具体实现**【封装】**起来
- 本质来说，就是基于抽象编程，不是在写控制程序，而是在定义【概念/角色/对象】，同时填充此【概念/角色/对象】的定义、属性、行为。

- 【概念/角色/对象】又有层次的划分，按照【概念一般性实例】和在特定情况下，【概念的特殊性(定制化)实例】，分别提供一般性和特殊性实例。

- 原则主要就是对具体如何做到的一些最佳实践做法的补充：**设计和实现分离**
  - 设计上，基于抽象的【对象/概念/角色】（接口、接口方法、抽象类、抽象类方法、模板方法）设计结构和流程。
  - 实现上，用实现了抽象接口的，具象的实现类实现具体的行为；具象的实现类，不能超越抽象设计的限制。

##### 原则理解

- 【概念】本身要足够独立、内聚，【概念】与【概念】之间做到不需要互相了解也能合作。
- 概念、类、方法，都要单一职责，在拆分和合并的取舍中，尽量**用拆分成原子的方法组合成一个个复杂行为**，而不要直接提供单独的复杂行为方法（好处是，使用者只需要了解自己最少需要了解的接口即可）。
- 接口、抽象类、方法的定义，尽量基于接口和抽象类。
- 要尽量使用合成/聚合，尽量不要使用继承 。

##### Java和面向对象的关系

- Java是一种，基于面向对象的编程思想，以及该思想的各种最佳实践原则，设计出来的编程语言。
- Java编程语言本身的语法特性和限制，实现了面向对象的各种原则，也限制了不能做出面向对象原则禁止的行为。
- 面向对象是一种抽象的编程方法论，Java是基于这种编程方法论的具体实现的具体的编程语言。

#### 原则

- 单一职责原则

  - 一个类，有且仅有一个职责

  - 所谓一个类的职责是指引起该类变化的原因，如果一个类具有一个以上的职责，那么就**会有多个不同的原因引起该类变化**，其实就是耦合了多个互不相关的职责，就会降低这个类的内聚性

- 开闭原则(OCP: Open Close Principle)：抽象具象分离原则/接口实现分离原则
  - 对拓展开放，对修改关闭
  - 动机：软件是变化的
  - 理解：一个已有软件如果要拓展，应该在不修改已有代码的基础上进行
  - 实现方式：抽象，把接口和实现分离
  - 实现开放-封闭的核心思想就是**对抽象编程，而不对具体编程**，**因为抽象相对稳定**。让类依赖于固定的抽象，这样的修改就是封闭的；而通过面向对象的继承和对多态机制，可以实现对抽象体的继承，**通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。**
- 依赖倒转原则(DIP: Dependence Inversion Principle)
  - DIP法则(依赖倒转, Dependence Inversion Principle ) :抽象不应当依赖于细节，细节应当依赖于抽象。
  - 理解：要依赖于抽象，不要依赖于具体，要针对接口编程，不针对实现编程。
  - 实现方法：传递参数，或者在组合聚合关系中，尽量应用（抽象）层次高的类。
  - DIP具体含义
    - 应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等
    - 要做到这一点，一个具体Java类应当只实现Java接口和抽象Java类中声明过的方法，而不应当给出多余的方法。
    - 如果希望遵守OCP法则，那么DIP法则是达到要求的途径。
- 接口分割原则（ISP: Interface Segregation Principle）
  - 使用多个专门的接口比使用单一的总接口要好
  - 目的：系统解开耦合，从而容易重构，更改和重新部署。
  - 理解：不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变 。根据客户需要的不同，为不同的客户提供不同的服务（定制服务）。
  - 定制服务：Customized Service,满足ISP法则，其目的在于为同一角色提供宽、窄不同的接口，以对付不同的客户端。
- 聚合复用原则（CARP：Composite/Aggregate Reuse Principle ）
  - 要尽量使用合成/聚合，尽量不要使用继承 。
  - 因为会受限于基类
- 里氏替换原则（LSP: Liskov Substitution Principle）- 抽象替换原则：更抽象的类一定可以被更具象的类替换。
  - LSP法则(里氏替换原则, Liskov Substitution Principle):使用指向基类(超类)的引用的函数，必须能够在不知道具体派生类(子类)对象类型的情况下使用它们。
  - 理解：任何基类可以出现的地方，子类一定可以出现。 LSP法则是对OCP法则的补充，OCP的关键步骤是抽象化，而基类和子类的继承关系就是抽象化的具体体现，所以LSP是对实现抽象化的具体步骤的规范。
- 迪米特法则（LoD：Law of Demeter )  -  概念内聚原则
  - 一个对象应当对其它对象有尽可能少的了解，不要和陌生人说话
  - 理解：只与你直接的朋友通信，而避免和陌生人通信。众所周知类（或模块）之间的通信越少，耦合度就越低，从而更有利于我们对软件的宏观管理。

#### 原则的应用

- 充血模型和贫血模型

  - 充血模型中，一个概念的内部定义和行为在一个类中

- 高内聚，低耦合；多聚合，少继承

  - 内聚：每个模块尽可能独立完成自己的功能，不依赖于模块外部的代码。

  - 耦合：模块与模块之间接口的复杂程度，模块之间联系越复杂耦合度越高，牵一发而动全身。

  - 目的：使得模块的“可重用性”、“移植性”大大增强;同时能确保在修改某一块代码时，修改造成的影响的辐射范围最小

  - 通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低

  - ```markdown
    # 功能块
    - 高内聚低耦合：减少模块之间的交互复杂度（接口数量，参数数据）
    
    # 类
    - 高内聚低耦合：减少类内部，对其他类的调用
    
    # 函数
    - 高内聚：尽可能类的每个成员方法只完成一件事（最大限度的聚合）
    - 低耦合：减少类内部，一个成员方法调用另一个成员方法
    ```

## 技术方案原则

- 数据与配置无关原则
- 基于原则推导行为
- provider需要向前兼容
- 接口按场景划分
