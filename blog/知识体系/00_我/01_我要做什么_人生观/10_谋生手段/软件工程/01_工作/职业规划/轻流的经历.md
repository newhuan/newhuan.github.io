# 轻流的经历

2024-05

TODO：阶段、问题、问题的解决方案

## 部署架构

### 主线

- 前后端分离部署 + 单体数据库 
- 后端集群部署
	- 更多的是为了高可用和热更新，而不是因为单纯为了提高并发数
- 后端集群分角色（计算节点 + http节点 + 单机节点 + 导入导出节点 + 报表节点。。。。）
	- 主要是因为单个请求可能过大，一个请求打崩一台服务器，为了避免服务器宕机对客户的影响，所以拆分
	- 热点功能的各种紧急处理机制，以及问题处理文档，同时解决方案脚本化，放在jenkins上快速执行
- 数据库分主从
	- 单个筛选sql的计算量和扫描行数过大，尤其是报表的请求，以及很多需要把数据放到内存中进行计算的高IO操作，导致服务器负载过高，所以分主从，防止只读服务器崩掉，影响核心功能的使用
- DTS数据同步到GP + 轻析数据分析（T + 1）
	- 先同步再拆分
	- 主要是为了提供数据分析服务，信息化的下一步数字化包含了对数据分析的需求
- 功能服务器单独部署(审计日志)
	- 感觉纯粹是杜伟的习惯，直接微服务化了；
	- 好处在于独立部署，部署不部署不影响主线
	*- DDD领域服务拆分
	- MongoDB(NoSQL)
	- 主要为了筛选那块的长期可维护性，以及单应用单表 + 字段索引优化性能

### 支线

- CDN
	- 阿里云CDN（海外加速），前端文件体积过大，不用CDN前端服务器的带宽扛不住
- 负载均衡：
	- Nginx反向代理 -> 阿里云负载均衡（服务器组）
	- 后端多服务器
- 缓存：
	- 单体Redis -> Redis集群
	- Redis集群其实一直没什么需求，不过遇到过redis数据全丢的问题，自定义编号全挂
- 配置文件：
	- 每台服务器物理存储配置文件 -> Nacos
	  - 方便更新、维护，且权限控制更完善
	- 解决配置文件集中管理的问题，服务器分角色之后，配置文件的种类越来越多，需要对配置文件做专门的管理
- 代码复用
	- common module -> springBoot starter + Maven私仓
	- 项目多起来了，部分代码需要复用，比如对接消息队列、日志配置、分页器、Jackson配置、接口数据结构、国际化、cors、arthas对接配置、工作日、id生成器、接口拦截器、配置文件加密、文件存储、springBoot的自动装配配置等
- 日志：
	- 每台服务器物理存储日志 -> Skywalking(ES\ZooKeeper\kafka\MinIO)
	- 解决日志需要登录服务器去看，或者要运维把日志从服务器上复制下来才能看的问题，而且服务器多了，日志被打在哪一台服务器上也变得随机起来
- 定时任务：
	- Spring定时任务
	- quartz -> powerJob（迁移）
		- quartz中把任务执行的方法的classPath写入了数据库里，导致这块文件目录不能随便乱动
		- quartz早期没有集群方案，用消息队列转发，后面有了消息队列方案之后，每台服务器要在配置文件中加一个唯一的InstanceId，对k8s部署不友好
- 消息队列
	- RocketMQ4 -> RocketMQ5
		- 阿里云不再售卖RocketMQ4
		- 分发机制过于愚蠢，结合自研的调度机制也不太好用
		- 使用场景是topic数量很多，单个topic的用量很低，收费过高
	- RabbitMQ（专有云本地部署使用）
	- Java进程内存队列
	- 各种紧急队列、分区键、调度策略
- 文件存储：
	- OSS
		- 大客户对安全要求很高，需要对接私有桶
- 邮件短信:
	- SendCloud
	- SendGrid（后废弃）
	- smpt 
- OCR
	- 百度OCR
- 电子签章
	- e签宝平台版 -> e签宝标准版（专有云可用）
		- 平台版的账号，专有云客户一般没法买，只能买标准版，所以如果专有云客户想用电子签章，轻流只能对接标准版的e签宝
- 服务器
	- 云服务器物理部署
	- 云服务器 + Docker容器部署 + Jenkins脚本部署
		- 服务器多了，服务器的操作系统杂了，需要标准化和自动化了
	- 容器云 + k8s容器编排
		- 运维的水平上去了
- Sentinel
	- 熔断、限流；防止用户接口调用频率过高
	
- 雪花ID做业务ID
	- 避免先建表再读id，然后把id用于其他的表，减小事务
	

### 其他

- 只有Web端，基本没有前后端版本不一致的问题
	- 停机更新、接受发布时报错
- Arthas
	- 分析工具

## 部署方式

- 脚本上传 + 脚本重启
- Jenkins脚本上传 + Jenkins脚本重启
	- 机房部署Jenkins，Gitlab
		- 停电、断网、固定IP
- K8s + Docker化部署
- UAT + 灰度
- Alpha环境
  - 解决本地测试问题

## 团队建设

- 团队搭建、团队管理、技术、过程、项目
- 2.5个人
	- 前后端运维、测试、开发一肩挑，啥都干
	- 排期每周开个会，一个在线excel搞定
	- 没有绩效
- 4个人
	- 2个人兼职运维，4个人都开发
	- 排期每周开个会，一个在线excel搞定
- 运维职能拆分
	- 单独设置运维部门，运维工作逐渐转移到运维部门
- 10人以内
	- 开始招聘架构师、实习生
	- 实习生能产出，但是产出的内容后面基本都要被重写一遍
	- 排期每周开个会，一个在线excel搞定
	- 绩效比较随便，CTO找几个人问一问，拉个绩效拉齐会搞定
- 20个人 2个组
	- 21年下半年，翻倍扩张，所有人一起捞简历、面试
	- 尝试招聘架构师、名校毕业生，全凭运气
	- 按产品分组，轻流一组，轻析一组，运气好有2个能用的小组长，能起到传帮带的作用，把团队搭起来了
		- 其他职能有在扩张的时候，缺少小班长角色的，团队扩张的时候遇到了很多问题
	- 整理新人入职文档，包括项目术语表、开发流程SOP、排期机制、模块文档等，写培训文档，录制培训视频，分工做；设计新人任务等
	- 开始维护开发任务文档
	- 开始搭建学习机制，比如技术分享、推荐书单、技术培训等
	- 开始制定Java编码规划、SQL规范
	- 重点任务开始建立机制，比如BUG分配轮值机制等
- 20个人 4个组 + 架构组
	- 按模块分组，确定模块守护者
- 20个人 2大组4小组 + 架构组
	- 按模块分组
- 20个人 4小组 + 架构组
	- 按模块分组
	- 后端周会
- 20个人 1个部门4个小组 + 架构组
	- 按模块分组
	- 模块守护者、分工负责人
		- 技术、团队
	- 后端周会
- 20个人 1个部门2个小组（架构组并入）
	- 核心支撑域分组
	- 后端周会

## 重构项目经历

- 矫正目标，持续不断地矫正目标，明确要解决的问题、解决问题的方案（大方向）、最终的交付物
	- 需求方和工程团队的诉求必然会有分歧，一个觉得客户需要什么，一个觉得如何实现更合理，所以更需要明确什么是问题和什么是解决方案
- 明确协同部门的负责人是谁，责任到人，必须有唯一的总负责人
- 调研，搞清楚现状；现在所有的功能点，以及功能点的具体实现方式；以及对解决方案的可行性demo验证
- 方案明细，在明确方案方向的基础上，设计具体的实现方案，包括模型设计、文件/项目结构设计、类关系图设计、功能组织的方式设计（拆分独立还是混合在一起，以什么形式拆分或合并等(starter)）
- 每天日会，沟通进度，讨论问题，讨论方案，督促进度
  - BUG确认会

- 砍功能、改功能
- 功能没梳理干净，没抽象整理好，重构出来的代码还是会杂乱，因为要实现的内容是杂乱的

## AI项目经历





## 轻流犯过的错误

- 面临变化的时候，没有意识到变化，没有针对变化更改开发模式和项目架构设计原则；导致模块之间，连环影响，稳定性极差，且无法优化
- 

## 问题集合

- 日志查看 & 下载：skywalking
- 错误收集：exception_record
- 配置文件维护管理：nacos
- 代码复用：maven 私仓（项目代码放在一个repo里，拆分不同的project）
- 定时任务：不能让客户自定义，应该提供模板（powerJob）
- 消息队列：要有限制、调度、降级、单独队列（RocketMQ5）、幂等、重新导入、进行中状态
  - 可观测性：发送、接收日志表
- CI/CD：手动上传更新 -> Jenkins -> k8s
- Java进程启动缓慢：不要用MybatisPlus、检查sentinal的初始化static代码
- BUG分发：分配（单点） -> 认领（人不多、责任清晰、自觉） -> 分配（人多、功能多、BUG多）
- 数据库连接数：根据实际情况配置
- 数据同步：flink or DataX，不要直接用jdbc
- 高可用&热更新：同功能配置多台服务器 + 负载均衡
- 海外访问：CDN海外加速
- 筛选脏数据：强数据类型，不允许不同数据类型之间的赋值
- 数据库查询压力大：分主从，报表节点直连从节点
- 缓存：所有Redis中的数据，数据库里都要持久化，因为缓存永远会丢
- 安全：完整的端到端加密（service mesh: islot）
- **文档：详细的功能文档是维护不起来的；维护核心概念表（最多加上模型图）、项目术语表，详细的功能逻辑放在代码和注释里**
- 加不了新节点、新字段：策略模式重构
- 非结构化核心数据存储：文档数据库（MongoDB）
- 信创对接多种数据库：每种数据库的SQL单独写一套Mapper.xml，不要混在一起写
- 反诈封禁：打110解封；网站要备案；减少支付功能；附件功能要买检查服务
- 定价：考虑成本和市场
- 软件项目管理
  - 目标识别、状态跟踪以及偏差纠正
  - 项目经理

- 软件过程管理
  - 人员、技术、过程
  - 框架、实践：Scrum+XP
  - 响应式、前涉式：面向计划/面向变化
  - 个人、团队：PSP、TSP
  - PMO




## 基础知识

- **变动频率（数据结构）：**软件系统中，**数据结构变动的频率更新，更稳定**，所以一般以数据结构为核心设计模型，把数据结构和针对数据结构的操作封装在一起就是所谓的面向对象
- **实体关系分离**：代表实体的数据结构的**实体表**，和代表实体间关系的**关系表(中间表)**，两者要拆分开，因为如果把实体间的关系也维护在实体数据结构中，那随着关系的增加，数据结构本身会充斥各种其他实体的ID（一些核心实体关系的ID可以考虑放在实体中维护）
- **事务大小：**状态机的状态变更 对比 多实体的转换方案的优势在于，**状态变更的事务更小**，只需要一条update，实体转换至少需要一条update加一条insert
- **易于变更：**软件开发中，变化是必然的，而且是相对高频的，所以在多个方案的选择中，选择更容易应对变化的方案。

- **好的抽象：**好的抽象可以简化代码，**减少理解代码所需的认知负荷（减少需要单独理解的实体、概念）**;如果这是以牺牲简单性和灵活性为代价的，那么抽象就失去了价值。

  - ```
    // 原始代码
    import http. client import json
    conn = http.client.HTTPSConnection("api.example.com")
    conn. request("GET", "/data")
    response = conn.getresponse()
    data = json.loads(response.read().decode())
    conn.close()
    // 抽象后的代码
    import requests
    response = requests.get("/data")
    data = response.json()
    ```

- **核心支撑判断原则：**业务逻辑永远是核心的，行业通用业务逻辑是更核心的，本应用特定的业务逻辑是次核心的；实现业务逻辑的具体代码，比如和数据库、中间件等的交互，是支撑的；依赖和控制方向的原则是，支撑部分的变更，不能导致核心部分的变更。





























































































